[
    {
        "created": "2022-02-17T15:49:16.206Z",
        "name": "c++",
        "tags": [
            "cpp"
        ],
        "content": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#ifdef LOCAL\r\n#include \"copypaste/debug.h\"\r\n#else\r\n#define debug(...) 42\r\n#endif\r\n\r\n#define endl '\\n'\r\n\r\nstruct fast_ios {\r\n    fast_ios() {\r\n        cin.tie(nullptr);\r\n        ios::sync_with_stdio(false);\r\n        cout << fixed << setprecision(10);\r\n    };\r\n} fast_ios_;\r\n\r\nint main() {\r\n#ifdef LOCAL\r\n    freopen(\"./data.in\", \"r\", stdin);\r\n#endif\r\n}",
        "contentType": "cpp"
    },
    {
        "created": "2022-03-21T16:16:01.926Z",
        "name": "get_prime",
        "tags": [
            "CPP"
        ],
        "content": "//时间复杂度O(n)\r\nconst int maxn = 1e5 + 5;\r\nbool is[maxn];\r\nint prm[maxn], id;\r\n// 每个数的最小质因子\r\nint minp[maxn];\r\nvoid get_prime() {\r\n    /*\r\n    数被筛掉的顺序：3 -> 3^2 -> 2*3^2 -> 2^2 * 3^2\r\n    即从最大的质数去填\r\n    */\r\n    int k = 0;\r\n    memset(is, 1, sizeof(is));\r\n    is[0] = is[1] = 0;\r\n    for (int i = 2; i < maxn; ++i) {\r\n        if (is[i]) {\r\n            prm[k++] = i;\r\n            minp[i] = i;\r\n        }\r\n        for (int j = 0; j < k && (i * prm[j] < maxn); ++j) {\r\n            is[i * prm[j]] = 0;\r\n            minp[i * prm[j]] = prm[j];\r\n            if (i % prm[j] == 0) break;\r\n        }\r\n    }\r\n    id = k;\r\n}",
        "contentType": "cpp"
    },
    {
        "created": "2022-03-22T04:34:38.385Z",
        "name": "get_mod",
        "tags": [
            "cpp"
        ],
        "content": "template <typename T>\r\nT inverse(T a, T m) {\r\n    T u = 0, v = 1;\r\n    while (a != 0) {\r\n        T t = m / a;\r\n        m -= t * a;\r\n        swap(a, m);\r\n        u -= t * v;\r\n        swap(u, v);\r\n    }\r\n    assert(m == 1);\r\n    return u;\r\n}\r\n\r\ntemplate <typename T>\r\nclass Modular {\r\n   public:\r\n    using Type = typename decay<decltype(T::value)>::type;\r\n\r\n    constexpr Modular() : value() {}\r\n    template <typename U>\r\n    Modular(const U& x) {\r\n        value = normalize(x);\r\n    }\r\n\r\n    template <typename U>\r\n    static Type normalize(const U& x) {\r\n        Type v;\r\n        if (-mod() <= x && x < mod())\r\n            v = static_cast<Type>(x);\r\n        else\r\n            v = static_cast<Type>(x % mod());\r\n        if (v < 0) v += mod();\r\n        return v;\r\n    }\r\n\r\n    const Type& operator()() const { return value; }\r\n    template <typename U>\r\n    explicit operator U() const { return static_cast<U>(value); }\r\n    constexpr static Type mod() { return T::value; }\r\n\r\n    Modular& operator+=(const Modular& other) {\r\n        if ((value += other.value) >= mod()) value -= mod();\r\n        return *this;\r\n    }\r\n    Modular& operator-=(const Modular& other) {\r\n        if ((value -= other.value) < 0) value += mod();\r\n        return *this;\r\n    }\r\n    template <typename U>\r\n    Modular& operator+=(const U& other) { return *this += Modular(other); }\r\n    template <typename U>\r\n    Modular& operator-=(const U& other) { return *this -= Modular(other); }\r\n    Modular& operator++() { return *this += 1; }\r\n    Modular& operator--() { return *this -= 1; }\r\n    Modular operator++(int) {\r\n        Modular result(*this);\r\n        *this += 1;\r\n        return result;\r\n    }\r\n    Modular operator--(int) {\r\n        Modular result(*this);\r\n        *this -= 1;\r\n        return result;\r\n    }\r\n    Modular operator-() const { return Modular(-value); }\r\n\r\n    template <typename U = T>\r\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n#ifdef _WIN32\r\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\r\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\r\n        asm(\r\n            \"divl %4; \\n\\t\"\r\n            : \"=a\"(d), \"=d\"(m)\r\n            : \"d\"(xh), \"a\"(xl), \"r\"(mod()));\r\n        value = m;\r\n#else\r\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\r\n#endif\r\n        return *this;\r\n    }\r\n    template <typename U = T>\r\n    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\r\n        value = normalize(value * rhs.value - q * mod());\r\n        return *this;\r\n    }\r\n    template <typename U = T>\r\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n        value = normalize(value * rhs.value);\r\n        return *this;\r\n    }\r\n\r\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\r\n\r\n    friend const Type& abs(const Modular& x) { return x.value; }\r\n\r\n    template <typename U>\r\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\r\n\r\n    template <typename U>\r\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\r\n\r\n    template <typename V, typename U>\r\n    friend V& operator>>(V& stream, Modular<U>& number);\r\n\r\n   private:\r\n    Type value;\r\n};\r\n\r\ntemplate <typename T>\r\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\r\ntemplate <typename T, typename U>\r\nbool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\r\ntemplate <typename T, typename U>\r\nbool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\r\n\r\ntemplate <typename T>\r\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r\ntemplate <typename T, typename U>\r\nbool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\r\ntemplate <typename T, typename U>\r\nbool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r\n\r\ntemplate <typename T>\r\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\r\n\r\ntemplate <typename T>\r\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r\ntemplate <typename T, typename U>\r\nModular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\r\ntemplate <typename T, typename U>\r\nModular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r\n\r\ntemplate <typename T>\r\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r\ntemplate <typename T, typename U>\r\nModular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\r\ntemplate <typename T, typename U>\r\nModular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r\n\r\ntemplate <typename T>\r\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r\ntemplate <typename T, typename U>\r\nModular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\r\ntemplate <typename T, typename U>\r\nModular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r\n\r\ntemplate <typename T>\r\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r\ntemplate <typename T, typename U>\r\nModular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\r\ntemplate <typename T, typename U>\r\nModular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r\n\r\ntemplate <typename T, typename U>\r\nModular<T> power(const Modular<T>& a, const U& b) {\r\n    assert(b >= 0);\r\n    Modular<T> x = a, res = 1;\r\n    U p = b;\r\n    while (p > 0) {\r\n        if (p & 1) res *= x;\r\n        x *= x;\r\n        p >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\ntemplate <typename T>\r\nbool IsZero(const Modular<T>& number) {\r\n    return number() == 0;\r\n}\r\n\r\ntemplate <typename T>\r\nstring to_string(const Modular<T>& number) {\r\n    return to_string(number());\r\n}\r\n\r\n// U == std::ostream? but done this way because of fastoutput\r\ntemplate <typename U, typename T>\r\nU& operator<<(U& stream, const Modular<T>& number) {\r\n    return stream << number();\r\n}\r\n\r\n// U == std::istream? but done this way because of fastinput\r\ntemplate <typename U, typename T>\r\nU& operator>>(U& stream, Modular<T>& number) {\r\n    typename common_type<typename Modular<T>::Type, long long>::type x;\r\n    stream >> x;\r\n    number.value = Modular<T>::normalize(x);\r\n    return stream;\r\n}\r\n\r\n/*\r\nusing ModType = int;\r\n \r\nstruct VarMod { static ModType value; };\r\nModType VarMod::value;\r\nModType& md = VarMod::value;\r\nusing Mint = Modular<VarMod>;\r\n*/\r\n\r\nconstexpr int md = 998244353;\r\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\r\n\r\n/*vector<Mint> fact(1, 1);\r\nvector<Mint> inv_fact(1, 1);\r\n \r\nMint C(int n, int k) {\r\n  if (k < 0 || k > n) {\r\n    return 0;\r\n  }\r\n  while ((int) fact.size() < n + 1) {\r\n    fact.push_back(fact.back() * (int) fact.size());\r\n    inv_fact.push_back(1 / fact.back());\r\n  }\r\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\r\n}*/",
        "contentType": "cpp"
    },
    {
        "created": "2022-03-22T04:46:41.432Z",
        "name": "get_utils",
        "tags": [
            "cpp"
        ],
        "content": "template <class T>\r\nauto vect(const T& v, int n) { return vector<T>(n, v); }\r\ntemplate <class T, class... D>\r\nauto vect(const T& v, int n, D... m) {\r\n    return vector<decltype(vect(v, m...))>(n, vect(v, m...));\r\n}\r\n\r\ntemplate <typename T>\r\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\r\nmt19937_64 mrand(random_device{}());\r\nlong long rnd(long long x) { return mrand() % x; }\r\nint lg2(long long x) { return sizeof(long long) * 8 - 1 - __builtin_clzll(x); }\r\n",
        "contentType": "cpp"
    }
]