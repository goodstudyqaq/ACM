# 几何扫描线
# 圆包含判断

- 挑战P258

~~一般情况下，如果题目给出**圆之间最多一个交点**，即要么不相交，要么一个圆包含另一个圆，要么共享一个点。这个时候如果需要处理出圆的包含关系，可以用扫描线的思想。~~

~~当扫描线移动到圆的左右两端时，需要把该圆的中心的 $y$ 值塞进 l 里或者从 $set$ 里删除，怎么判断该圆的包含情况呢，只需要取离当前圆心 $y$ 最近的那两个 $y$ 值就行了。~~

~~注意：这样处理完实际上是一个不完全的包含关系，如果想得到完整的包含关系，对其进行拓扑排序即可。~~

不好拓展，先记录一下挑战的问题和做法。。

## 问题

给出 $n$ 个不相交的圆，求所有不被其他圆包含的圆。

## 做法

扫描线，$Event$ 存圆的左右两个端点的位置，一个是起点，一个是终点。$Set$ 里存已经扫到的圆的 $y$ 坐标。每次扫到一个圆的起点时，就用 $lower\_bound$ 找到离他最近的两个圆，进行判断是否包含，同时把这个新的圆加入到 $Set$ 中。

```cpp
bool check(int idx1, int idx2) {
    double x = V[idx1].x - V[idx2].x;
    double y = V[idx1].y - V[idx2].y;
    double r = V[idx1].r + V[idx2].r;
    return x * x + y * y <= r * r;
}
void work() {
		vector< pair< double, int > > event;
    for (int i = 1; i <= N; i++) {
        cin >> V[i].r >> V[i].x >> V[i].y;
        event.push_back(make_pair(V[i].x - V[i].r, i));
        event.push_back(make_pair(V[i].x + V[i].r, i + N));
    }

    sort(event.begin(), event.end());
    set< pair< double, int > > S;
    vector< int > ans;
    for (int i = 0; i < event.size(); i++) {
        pair< double, int > it = event[i];
        // cout << i << ' ' << it.first << ' ' << it.second << endl;
        if (it.second <= N) {
            set< pair< double, int > >::iterator it2 = S.lower_bound(make_pair(V[it.second].y, it.second));
            if (it2 != S.end() && check(it2->second, it.second)) continue;
            if (it2 != S.begin()) {
                it2--;
                if (check(it2->second, it.second)) continue;
            }
            ans.push_back(it.second);
            S.insert(make_pair(V[it.second].y, it.second));
        } else {
            if (S.count(make_pair(V[it.second - N].y, it.second - N))) {
                S.erase(make_pair(V[it.second - N].y, it.second - N));
            }
        }
    }
}
```

## 拓展问题

给出 $n$ 个最多相交于一个点的圆，求圆包含关系。

相交与一个点太难判断了。。