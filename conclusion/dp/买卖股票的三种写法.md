# 买卖股票的三种写法
以三道题为例：

[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

[https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum/](https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum/)

[https://codeforces.com/problemset/problem/1420/C2](https://codeforces.com/problemset/problem/1420/C2)

# dp

$dp[i][0/1]$  表示在第 $i$ 个股票的时候是否持有股票，那么有状态转移 

$$
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + a[i])\\dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - a[i])
$$

根据 $dp$ 的结果去回溯找操作数最小的方案也很简单，这里就不赘述了。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector< vector< int > > dp(n + 1, vector< int >(2, 0));
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
            } else {
                dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            }
        }
        return dp[n - 1][0];
    }
};
```

# 转化 + 贪心

由于有持有股票只有一个的限制，那么问题可以转化成取若干个**不相交的**区间$[l_i, r_i]$ 使得下式最大

$$
Money = \sum_i^xa[r_i] - a[l_i]
$$

再进一步思考，这个式子转化成只要相邻的 $a[i] < a[i + 1]$ ，那么就对 $Money$ 有正的贡献，所以要算上去。所以式子进一步转化为 

$$
Money = \sum_{i}^n max(0, a[i] - a[i-1])
$$

```cpp
class Solution {
public:
    int maxProfit(vector<int>& a) {
        int n = a.size();
        int res = 0;
        for (int i = 0; i < n - 1; i++) {
            res += max(0, a[i + 1] - a[i]);
        }
        return res;
    }
};
```

这种做法没办法直接找到操作数最小的方案，需要在进一步做转换。

# 找到本质

这里有两个问题

1. 这个题的本质是什么？
2. 明明这个题买卖股票都是对后面有后效性的，为什么能贪心呢？

继续分析上面的式子，可以发现它的值是等于若干个连续递增区间的差，那么我们只要找到连续递增的区间就行了。

连续递增的区间换句话说其实就是找波峰波谷，即判断 $a[i] > a[i - 1] \&\& a[i] > a[i+1]$ 或者 $a[i] < a[i - 1]  \&\& a[i] < a[i + 1]$，但是有相等的怎么办呢？我想了一下，买股票取第一个相等的，卖股票取最后一个相等的，记录方案的时候去 check 上一次购买和这一次卖的价格是否一样，这样是不会出现错误的。即上述判断换成 $a[i] < a[i - 1] \&\& a[i] <= a[i +1]$ 的时候买，$a[i] >= a[i - 1] \&\& a[i] > a[i + 1]$ 的时候卖。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& nums) {
        long long res = 0;
        int n = nums.size();
        vector<int> real_nums;
        real_nums.push_back(1e4 + 1); // 前面放一个最大的，使得第一个可以买，不能卖
        for (int i = 0; i < n; i++) {
            real_nums.push_back(nums[i]);
        }
        real_nums.push_back(-1); // 最后放一个最小的，使得最后一个可以卖，不能买
        nums = real_nums;
        vector<int>ans;
        for (int i = 1; i <= n; i++) {
            int l = i - 1;
            int r = i + 1;
            bool flag1 = true, flag2 = true;
            flag1 &= (nums[i] >= nums[i - 1]);
            flag2 &= (nums[i] < nums[i - 1]);
            flag1 &= (nums[i] > nums[i + 1]);
            flag2 &= (nums[i] <= nums[i + 1]);
            if (flag1) {
                res += nums[i];
                if (*ans.rbegin() == -nums[i]) {
                    ans.pop_back();
                } else {
                    ans.push_back(nums[i]);
                }
            }
            if (flag2) {
                res -= nums[i];
                ans.push_back(-nums[i]);
            }
        }

        for (int i = 0; i < ans.size(); i++) {
            cout << ans[i] << ' ';
        }
        cout << endl;
        return res;
    }
};
```

第二个问题的本质其实是探讨这题的局部贪心是否和整体 $dp$ 相等。打表能够发现，在一个下降的区间，$dp[i][0]$  的值会保持不变，$dp[i][1]$ 的值在持续变大，那么这意味着中间的过程没有意义，只需要考虑两个端点，就可以进行状态转换了。同理，在一个上升的区间，$dp[i][0]$ 的值会上升，而$dp[i][1]$ 的值会保持不变，这也意味着只需要考虑两个端点就行了，所以通过 $dp$ 也能发现它的值只和波峰波谷的状态有关，和中间过程的状态无关。所以就可以从 $dp$ 往贪心方向进行转换了。

需要注意的是，通过打表找到状态转移点的规律是一个很重要的想法！很多情况下发现了状态转移的规律意味着减少了不必要的状态枚举，即减少了时间复杂度。虽然在这题并未体现。