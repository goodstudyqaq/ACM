# 初识 DP

- 注：本文译自[https://apps.topcoder.com/forums/?module=Thread&threadID=700080&start=0](https://apps.topcoder.com/forums/?module=Thread&threadID=700080&start=0)

# 问题描述

在 SRM 的题目中，大约有 25% 的问题带有 dp 的 tag。出题人很喜欢出有关 dp 的题目，因为每个 dp 问题在某种意义上都是原创的。所以在算法竞赛中，你必须掌握 dp 的知识。

学习 dp 的最简单的方法就是举例子，本篇文章涵盖了一些 dp 的例子，但对于初学者来说，建议先看其他的 dp 入门教程，推荐 [From novice to advanced](http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=dynProg)。本篇博客的目的是介绍 dp 的各个方面。

# 解决方案

## 入门(硬币问题)

什么是 dp 呢，我们应该怎么去描述它？

对于 dp 来说，其实没有一个很好的定义。它可以被描述成一个依赖于**初始状态**，**递推公式或者连续状态之间的关系**的算法。一个状态的答案可以表示成一个子解决方案。初始状态依赖于给定的输入，然后状态一个接着一个被求出，直到所有的状态都被求解完毕。

首先让我们来看看一个非常简单的问题，它能帮助我们更好地理解后面我们要讨论的东西：

有 n 个硬币，他们的重量为 W1, W2, W3 ..., Wn，给出一个总和 S，要求使用尽可能少的硬币，他们的重量和为 S(每个硬币都有无穷个)，或者说明没有方案可以达到重量为 S 。这个问题是著名的[无穷背包](https://en.wikipedia.org/wiki/Knapsack_problem#Unbounded_knapsack_problem)问题。对于这个题的状态，我们可以定义为 (P) -> k，表示部分和 P 的解决方案，P 不超过 S，k 是得到重量 P 时需要的最少硬币个数。

因此这个题目的初始状态为 (0)，然后我们需要根据之前的已知解去求解后面的解，在这个问题里，(P) 的前继状态 (Q) 总是意味着 Q 小于 P，因此总是表示一个小于 P 的解决方案。一开始我们的状态为 (0)，然后求出 (P1), (P2), (P3) 等等状态的结果，最终求出 (S) 的结果。这里有一个有关 dp 比较重要的性质 - 一个状态一定要等它的所有前继状态求解完后才会进行求解。

最后但同样重要的是，如何找到状态之间的关系。对于简单问题来说，状态的关系很容易找到，但是对于复杂的问题来说，我们需要做一些额外的操作。

我们继续考虑上面说的问题，对于总和 P 以及硬币的重量为 V1, V2, ..., Vj。 总和 P 的结果一定是由一个更小的总和 Q 加上一个硬币 Vi 且Q + Vi = P 得来的。那么显然 P 状态是由有限个状态递推而来的，因此 (P) 是由 (Qi) + 1 并取最小值得来的。

如何用代码实现呢？ DP 的结果通常用数组去存储，在我们的例子中 `mink[0...S]` 表示状态的结果，换句话说 `mink[P] = k` 表示状态 P 的结果。我们根据某种顺序来循环计算，下面的代码包含本题的递推式，结果表，以及结果。

```cpp
/* 状态转移式:
  {k[0] = 0;
  {k[P] = min_i (k[P-Wi] + 1);   (for Wi <= P)
*/
/* 对于输入: S=11, n=3, W = {1,3,5}
   DP 结果表:
  P = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11
  ------+--+--+--+--+--+--+--+--+--+--+--
  k = 0 |1 |2 |1 |2 |1 |2 |3 |2 |3 |2 |3
*/
int n, S;                                        //n: 硬币的个数, S: 希望得到的重量
int wgt[MAXN];                                   //硬币的重量数组: {1, 3, 5};
int mink[MAXW];                                  //DP 的结果 k;

  mink[0] = 0;                                   //初始化 0
  for (int P = 1; P<=S; P++) {                   //遍历所有的状态
    int minres = 1000000000;
    for (int i = 0; i<n; i++) if (wgt[i] <= P) { // 假设硬币 i 为最后一个硬币
      int tres = mink[P - wgt[i]] + 1;           //硬币个数为前者 + 1
      if (minres > tres) minres = tres;          //选择最小的硬币个数
    }
    mink[P] = minres;                            //把结果存到 mink 里
  }
  int answer = mink[S];                          // 整个问题的答案为 mink[S]

```

## 入门(LCS 问题)

考虑另一个问题，给出 2 个单词，找到他们的[最长共同子序列(longest common subsequence)](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)，比如两个单词 "quetzalcoatl" 和 "tezcatlipoca"，它们的 LCS 为 "ezaloa"

为了解决这个问题，我们引入它的子问题，给出第一个单词的前缀和第二个单词的前缀，找到它们的 LCS。设第一个单词的前缀的长度为 i，第二个单词的前缀的长度为 j，那么状态可表示为 (i, j) -> L, i 表示第一个单词的前缀的长度，j 表示第二个单词的前缀的长度，L 表示这两个前缀的 LCS。解决方案为从 (0, 0) 开始考虑，然后依次往它后面加字符去计算该状态的结果，直到 (n1, n2) 被计算。

接下来，我们分析一下它的递推式，我们用 L[i, j] 表示 DP 的结果。显然，如果其中一个的前缀为空，那么 LCS 一定为 0. 则 L[i, 0] = L[0, j] = 0。当 i 和 j 都为正数时，我们需要考虑一下情况。

1. 第一个单词的最后一个字符没有被使用，所以它可以从子序列中删掉，相应的转移式子为 L[i, j] = L[i - 1, j]
2. 第二个单词的最后一个字符没有被使用，所以它可以从子序列中删掉，相应的转移式子为 L[i, j] = L[i, j - 1]
3. 两个单词的最后一个字符都被使用，当然，它们肯定是要相等的。那么递推式为 L[i, j] = L[i - 1, j - 1] + 1

对于上述 3 种情况，我们取结果的最大值。

实施方面，DP 的结果存到一个二维数组里，我们可以用两层循环去计算该结果，而循环的顺序是一定要非递减的，因为状态(i, j)依赖 (i - 1, j)，(i, j - 1), (i - 1, j - 1)

```
/* 递推式
  {L[i,0] = L[0,j] = 0;
  |            {L[i-1,j],
  {L[i,j] = max|L[i,j-1],
               {L[i-1,j-1]+1   (只有最后一个相等的时候才会有这个转移)
*/
/* 结果:
   S|    t  e  z  c  a  t  l  i  p  o  c  a
T ji| 0  1  2  3  4  5  6  7  8  9 10 11 12
----+--------------------------------------
  0 | 0  0  0  0  0  0  0  0  0  0  0  0  0
q 1 | 0  0  0  0  0  0  0  0  0  0  0  0  0
u 2 | 0  0  0  0  0  0  0  0  0  0  0  0  0
e 3 | 0  0  1  1  1  1  1  1  1  1  1  1  1
t 4 | 0  1  1  1  1  1  2  2  2  2  2  2  2
z 5 | 0  1  1  2  2  2  2  2  2  2  2  2  2
a 6 | 0  1  1  2  2  3  3  3  3  3  3  3  3
l 7 | 0  1  1  2  2  3  3  4  4  4  4  4  4
c 8 | 0  1  1  2  3  3  3  4  4  4  4  5  5
o 9 | 0  1  1  2  3  3  3  4  4  4  5  5  5
a 10| 0  1  1  2  3  4  4  4  4  4  5  5  6
t 11| 0  1  1  2  3  4  5  5  5  5  5  5  6
l 12| 0  1  1  2  3  4  5  6  6  6  6  6  6
*/
int n1, n2;                                              // 单词的长度
char str1[1024], str2[1024];                             // 单词
int lcs[1024][1024];                                     // DP 结果

  for (int i = 0; i<=n1; i++)                            //遍历所有的状态 (i,j)
    for (int j = 0; j<=n2; j++) {
      if (i == 0 || j == 0)
        lcs[i][j] = 0;                                   // DP 最初的状态
      else {
        lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]);       //case 1 和 case 2
        if (str1[i-1] == str2[j-1])
          lcs[i][j] = max(lcs[i][j], lcs[i-1][j-1] + 1); //case 3
      }
    }
  int answer = lcs[n1][n2];

```

## 讨论

### 与记忆化的比较

有另一项技巧，叫做记忆化，会在后面的”优化递归方案“讲到，记忆化和填表法(backward DP)非常相似，两种方法都根据状态转移解决问题，这意味着它们都是去计算出一些状态域的结果。 一些状态的结果取决于给定的初始值，其他的状态结果根据它之前的状态的结果。DP是根据 coder 定义的顺序去遍历状态，而记忆化是根据 dfs 的顺序去遍历状态，DP 不会重复计算一个状态 2 次，就和完全记忆化的递归一样。记忆化不会计算那些没有必要的状态 - 它是一个懒惰算法，只有这个状态会影响结果的时候才会被计算，下面是记忆化的一些优点和缺点：

1. +写法简单
2. +不用显示的写出状态转移顺序
3. +只会计算有用的状态
4. 只能用于填表法
5. 比普通的 DP 慢(常数大)

大多数 DP 的问题可以分为两类：最优解问题和组合问题。最优解问题是让你给出一个可行解，使得结果最小或者最大。而组合问题是让你算出某种东西的个数或者概率。让我们仔细研究这些问题。

### 最优解问题

最优解问题是指根据一些目标函数去计算出最优解的一类问题。上面说的硬币问题和 LCS 都算优化问题。它们的循环方程与这个类似：$R[s] = min(F1(R[i], R[j], ..., R[k]), F2(R[u], R[v], ..., R[w]), ..., Fl(R[q], R[p], ..., R[z]))$ $R$ 数组存的是 DP 的结果，简单来说，DP的结果取决于子状态的一个最值，所有的结果都是根据它之前 的状态得来的。比如硬币问题，考虑一个状态时，前面所有的硬币情况都被计算，每种情况都会对当前状态有一个贡献，而当前状态会取所有贡献的最小值作为答案。在 LCS 问题中，则会考虑当前状态的三个子状态，第一个单词的最后的字符没有使用，第二个单词的最后字符没有使用，两个单词的最后的字符都没有使用。

我们通常会使用一个极值来初始化 DP 数组，这个值不会对结果有影响。比如最小问题，我们就会用一个极大值 inf 去初始化，因为比任何结果都要大，状态值为 inf 就会被视为一个无效状态。最大问题则会用一个极小值去初始化。

DP 的状态通常可以看成一个问题的子问题，它们的结果可以表示为整个问题的部分答案。比如在 LCS 问题中子问题为两个原始串的前缀的LCS。DP 依赖最优子结构这个属性，即整个问题的最优解会依赖部分问题的最优解。比方说硬币问题，重量为 S 的最优解包括了一个重量为 w 的硬币，那么 计算得到的状态 S - w 的方案一定也是最优解。

最优子结构这个性质十分重要，如果它不成立，则子方案不是最优的，那么它会在 DP 的中途被丢掉，通常计算得到的结果也是有问题的，因为它没有得到最优解。比如经典的 [TSP 问题](https://en.wikipedia.org/wiki/Travelling_salesman_problem)，设状态为 (k, l) → D，D 为 从 0 走了 k 个城市后到达 l 的最短路。最优子结构在这个状态不成立：考虑它最后答案的最短路径，固定城市个数已经最后的城市并不总是最短，因此这个 DP 是错的。

### 组合问题

组合问题是让你算出某种东西的个数或者概率，通常这个东西的个数会很大，所以会给你一个 mod。它的递推式就像 $R[s] = F1(R[i], R[j], ..., R[k]) + F2(R[u], R[v], ..., R[w]) + ... + Fl(R[q], R[p], ..., R[z])$。和最优问题相比，就是把取 min 换成了求和。总和意味着 F1, F2, ... Fl 组成了状态 s 的所有可能(即枚举的子状态需要不重不漏)。

举个例子，我们可以把硬币问题改成计算所有重量为 S 的方案个数。那么状态 (P) → k 表示重量为 P 时的所有方案个数为 k，递推式和之前相比有一点点的不同。

```cpp
/* DP 递推式:
  {k[0] = 1;
  {k[P] = sum_i (k[P-Wi]);   (for Wi <= P)
*/
/* 输入为: S=11, n=3, W = {1,3,5}
   DP 结果表:
  P = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11
  ------+--+--+--+--+--+--+--+--+--+--+--
  k = 1 |1 |1 |2 |3 |5 |8 |12|19|30|47|74
*/
```

对于组合问题，当然也有初始值，一般来说是求和问题，所以初始值为 0。另外需要注意的是，任何一个子状态不能被重复计算 2 次。

### 刷表法 vs 填表法

上面用的 DP 的方法都是填表法，填表法的思路为，状态从前往后遍历，计算当前状态依赖之前计算的状态。使用填表法的话就需要得到当前状态和它前继状态的依赖关系。

刷表法的话，它使用起来其实更加方便。它的思路为，遍历所有的状态，并且根据当前的状态去更新依赖它的状态的值。每次更新的状态一定是还没有遍历到的状态。当一个状态被遍历到时，那么它的结果一定是被计算好的。刷表法其实没有用循环方程，所以其实不太好用数学的方式证明它的正确性，因为刷表法得到的结果是根据一部分状态的结果得来的。 使用刷表法的话同样也需要初始化。

第一个例子同样是硬币问题。假设你有状态为 P 的最优解，那么你可以给它加上任意一个硬币，从而去推导 P + wi 的一个解。

```cpp
/* 状态转移:
  {k[0] = 1;
  {(P)->k ===> (P+Wi)->nk    add k to nk
*/
  res[0] = 1;                                 //初始化 0 的方案数为 1
  for (int p = 0; p<s; p++)                   //遍历所有的状态
    for (int i = 0; i<n; i++) {               //遍历所有的硬币
      int np = p + wgt[i];                    //新状态为 np
      if (np > s) continue;                   //那么可以从 p 过度到 np
      res[np] += res[p];                      //更新 np 的解
    }
  int answer = res[s];                        //答案和之前一样
```

第二个例子为 LCS 问题，它要求最大，所以我们要将它初始化为一个极小值。状态 (0, 0) → 0 表示两个字符串前缀长度为0 时的 LCS 等于 0.当我们已知状态 (i, j) → L 时，我们可以有三种方式往后递推。

1. 第一个字符串前缀加一个字符，不改变结果。
2. 第二个字符串前缀加一个字符，不改变结果。
3. 两个字符串都加一个字符，且这个字符相等，那么结果 + 1.

对每一次转换，我们都需要对后面的状态的结果进行一次松弛操作，即如果这个状态的结果比此次计算的大，那么不做修改，否则更新结果。代码如下：

```cpp
/* 状态转移
  {L[0,0] = 0;
  |          /> (i+1,j)->relax(L)
  {(i,j)->L ==> (i,j+1)->relax(L)
             \> (i+1,j+1)->relax(L+1)  (当且仅当最后一个字符相等)
*/
void relax(int &a, int b) {                   //松弛操作
  if (a < b) a = b;
}
 
  memset(lcs, -63, sizeof(lcs));              //初始化 DP 结果为负数
  lcs[0][0] = 0;                              //初始化 (0,0)->0
  for (int i = 0; i<=n1; i++)
    for (int j = 0; j<=n2; j++) {             //遍历所有的状态
      int tres = lcs[i][j];
      relax(lcs[i+1][j], tres);               //第一种转移
      relax(lcs[i][j+1], tres);               //第二种转移
      if (str1[i] == str2[j])                 //当下一个字符相等
        relax(lcs[i+1][j+1], tres + 1);       //第三种转移
    }
  int answer = lcs[n1][n2];
```

### 最优解问题-恢复方案

最优解问题往往需要得到最优解以及它的方案。但是 DP 存的只是最终解，它不会告诉你方案是啥。在实际使用中，没有方案的话，计算得到的最终解也是无用的。所以 topcoder 里的问题通常包含输出方案。因此，我们需要知道如何得到它的方案。

在大多例子中，它的状态转移是依赖前继状态的，换句话说，它的状态是由前面的一个状态递推而来的。在这种情况下，我们只要知道所有状态所依赖的前继状态，那么就很容易恢复方案了。这里有两种办法。

第一种办法是从后往前重新计算 DP，首先我们选择一个最终状态 f，然后就像之前的那样，我们遍历它的所有前继状态，如果其中的一个状态 s 的结果能够转移到 f 的结果，那么就可以看成 f 是从 s 状态转移而来的，虽然有可能是有很多状态都满足这个条件。然后我们再根据上述方式去找谁能到 s，直到我们到达起始状态。

第二种办法就是在 DP 的同时存储每个状态的前继状态。当状态 u 能对 s 有影响时，且产生的结果更优，那么我们需要存一个反向链接，即从 s 到 u。那么我们只要从最终状态开始，根据这个反向链接就能找到方案。当然你可以存一些其他的信息，来简化找方案的方式。

第一个办法有很多缺点，它很慢，他需要把 dp 的代码复制粘贴，它只适用于填表法。它仅适合于当我们没有额外的内存去存下反向链接时的情景。一般情况下我们都推崇第二种办法，因为它很简单，并且刷表法和填表法都可以用。当它有多个满足条件的前继状态，你甚至可以存一条链，并用递归的方式去找到所有方案。

还是拿硬币问题举个例子，除了反向链接那部分，其他的代码和之前类似。后面恢复方案的代码也很简单。

```cpp
/* 对于输入: S=11, n=3, W = {1,3,5}
   DP 结果 + 前继表:
  P  = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11
  -------+--+--+--+--+--+--+--+--+--+--+--
mink = 0 |1 |2 |1 |2 |1 |2 |3 |2 |3 |2 |3
prev = ? |S0|S1|S0|S1|S0|S1|S2|S3|S4|S5|S6
item = ? |I0|I0|I1|I1|I2|I2|I2|I2|I2|I2|I2
*/
 
int mink[MAXW];                       //DP 的结果
int prev[MAXW], item[MAXW];           //prev: 上一个状态 item: 上一个状态使用的硬币下标
int k;                                
int sol[MAXW];                        //sol[0,1,2,...,k-1] 方案
 
  memset(mink, 63, sizeof(mink));     //初始化为无穷大
  mink[0] = 0;                        //DP[0] = 0
  for (int p = 0; p<s; p++)           //遍历所有的状态
    for (int i = 0; i<n; i++) {       //遍历所有的硬币
      int np = p + wgt[i];            //np 为从 p 能得到的状态
      int nres = mink[p] + 1;         //结果
      if (mink[np] > nres) {          //松弛 np 的结果
        mink[np] = nres;              
        prev[np] = p;                 //存上一个状态为 p
        item[np] = i;                 //使用的硬币为 i
      }
    }
 
  int answer = mink[s];
  int cp = s;                         //从最终状态s开始
  while (cp != 0) {                   //直到当前状态为 0
    int pp = prev[cp];                //得到上一个状态
    sol[k++] = item[cp];              //得到所使用的硬币下表
    cp = pp;                          //把状态移到 pp
  }
```