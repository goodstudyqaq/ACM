# 斜率 DP 整理
# 前向依赖知识点

# 算法简介

理解的还不太深刻，先写个 CF319C 的题解

有 $n$ 棵树，长度为 $a$，现在有一把斧头，一次充电只能砍 $1m$，砍完第 $i$ 棵树后在 $i$ 那里充电价格为 $b[i]$, 现在限定 $i < j$ 时 $a[i] < a[j], b[i] > b[j]$，且$a[1] = 1, b[n] = 0$。最初免费送一格电，问最少花多少钱能把树全部砍完。

容易想到花最少的钱把第 $n$ 颗树砍完就完事了。那么 $dp[i]$ 表示砍完第 $i$ 颗树的最小花费，那么 

$$
dp[i] = min_{j < i}\{dp[j] + b[j] * a[i]\}
$$

复杂度 $n^2$ 爆炸！

怎么优化呢？设 $j < k$, 且$k$是最优的点。那么可得

$$
dp[k] + b[k] * a[i] < dp[j] + b[j] * a[i]
$$

移向后可得

$$
a[i] > \frac{dp[k] - dp[j]}{b[j] - b[k]}
$$

我们尝试理解一下这个式子，能得到以下一些重要信息：

1. 当满足这个式子时，$k$ 这个点就是比 $j$ 优的，且由于 $a$ 是递增的，那么这个优，是不变的！所以我们在递推时可以永远删掉 $j$ 这个点。
2. 按照 1 所说，我们维护一个有效点的下标数组 $q$，可以发现这个数组满足任意三个连续的下标带到上述式子时的两个值是递增的，即：

$$
\frac{dp[q[i + 1]] - dp[q[i]]}{b[q[i]] - b[q[i + 1]]} >\frac{dp[q[i]] - dp[q[i - 1]]}{b[q[i - 1]] - b[q[i]]}
$$

- 如果不满足上述式子的话，那么第 $i$ 个点一定会被第 $i + 1$ 个点取代，因为 左边的值更小，小意味着更优！

说到这里，就不难理解为什么用一个单调队列去维护下标数组了。

注意：可以发现题目中的两个关键条件 $a[i] < a[i + 1], b[i] > b[i + 1]$ 缺一不可。

# 代码实现

# 套路总结



# 题单

- [https://codeforces.com/contest/319/problem/C](https://codeforces.com/contest/319/problem/C)
    
    斜率 dp 板子题，给出多个 y = kx + b 的直线，求给定 x 时 y 的最大值。