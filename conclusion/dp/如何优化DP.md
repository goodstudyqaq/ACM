# 如何优化 DP
- 注：本文译自：[https://apps.topcoder.com/forums/?module=Thread&threadID=697925&start=0](https://apps.topcoder.com/forums/?module=Thread&threadID=697925&start=0)

# 问题

当你想出 DP 的递推式，甚至都写好了代码，但是因为时间或者空间复杂度不满足的时候，这个时候我们就需要学习一些优化 DP 的技巧。

# 方案

大多数 DP 问题要么是组合问题，要么是最优解问题，前者我们需要计算某个东西的个数，即根据前继状态进行求和，而后者则是求最值，即根据前继状态进行取min或者max。根据题目类型的不同，主要操作就是优化求和或者取min/max. 下面是几种优化方案。

## 合并等效状态

实际上，这也不算 DP 的优化方案，而是 DP 的一个原则。任何具有等效状态的递归都可以用 DP 去优化。如果没有等效状态的话，从递归变成 DP 其实也没用。

比方现在的状态我们定义为 (s) → R，现在有两个特殊状态 x 和 y，如果最终的答案是根据相同的方式去依赖它们，换句话说，这两个状态对最终的答案的影响的方式没有区别，那么它们两个是等效状态。如果你的状态有很多等效状态的话，你定义的状态其实不好，需要重新构建。所有的等效状态可以合并为一个，对于组合问题来说，合并后的状态的值是等于所有等效状态的和，而对于最优解问题来说，合并后的状态的值是等于所有等效状态的值的最值，这样就可以定义好新的状态域了。定义好之后，需要额外写一个状态转换的函数。

比方说 [TSP 问题](https://en.wikipedia.org/wiki/Travelling_salesman_problem)，暴力做法就是从起点 0 开始，维护当前已经走过的点，暴力递归所有没走的点，然后取极值。这个问题递归方法的状态定义和方式很明显。但是呢，我们可以注意到状态 (0, A, B, L) 和 (0, B, A, L) 其实是等效的，前面走的点的顺序对后面的结果是没有影响的。能够产生影响的只有已经走过的点集以及当前所在的点，这意味着我们的状态可以重建，即我们可以用 (S, L) → R 来表示状态，S 表示已经走过的点集，L 是当前所在的点，R 是最短路。那么复杂度从暴力递归的 O(N - 1)! 变成了 O(2^N*N).

## 删掉不可能的状态

如果一个状态的结果永远是等于 0 或者 inf。删掉它是一个不错的选择，因为它对结果没有影响。不可能的状态可能有以下来源：

1. **显式参数依赖**：如果一个状态定义为 (A, B),但是对于所有的状态的 B = f(A)。那么 B 这个参数是没有意义的，可以删掉。如果我们需要 B 这个参数做一些转换，也可以使用 f(A) 计算得到 B。这样做之后状态域可以大大的减少。
2. **隐式参数依赖**：这种情况更糟，假设我们的状态为 (A, B)，并且所有可能的状态 f(A, B) = 0。换句话说，对于所有状态来说，都有一个特性，那么最好的办法是可以把它做一个转换，即将其中一个参数变成显式依赖其他的参数。这样做的话，我们就可以用第一种办法，或者说我们知道 B = f1(A) 或者 f2(A) 或者 f3(A)...那么我们可以将状态从 (A, B) 变成 (A, i), i = 1... k。如果还是不行的话，那么可以用方案4.
3. **参数不等式：**基本的方法就是设置循环参数的范围。比如状态 (i, j) 且 i < j。我们可以这样写 $for(i=0;i<N;i++) for(j=i+1;j<N;j++)$ 或者 $for(j=0;j<N;j++) for(i=0;i<j;i++)$ 。这样我们可以避免无效状态，并且平均速度是 2 倍。如果有 k 个参数，且满足非降这个条件的话，那么平均速度为 k! 倍。
4. **不用思考的方法：**即使很难找到哪些状态是无效的，它们存在的事实也是可以被利用的，下面是几个方法：
    1. 不处理它们：在循环内部加一个类似 $if (res[i][j]==0) continue;$ 的语句，这个方法一定要用，因为代码很简短但加速可能很快。它不会减少状态域的大小，但可以节省处理的时间。
    2. 使用记忆化：和 DP 类似，但是只处理需要的状态，这个必须在写代码之前决定，因为和普通 DP 的代码不一样。
    3. 使用 map 去存储：这样不可能的状态不会吃掉内存和时间，但是这样做会损失一些复杂度: 用 order map：O(logn)，unorder map: slow O(1)，且 unorder map 的内存开销会大一点。并且需要重写很大一部分代码去实现它。

## 只存两层状态

如果 DP 的状态分层的话，这个方法很有用。假设状态为 (i, A)， i 表示层数的下标，而 A 表示其他参数，且状态转移只依赖相邻的两层。换句话说就是 (i, A) 只依赖状态 (i - 1, *)，那么我们就可以只存 2 层状态，当下一层的状态都计算完了，当前层就可以被丢弃了。

内存里只有两层状态，一层是当前层，一层是上一层(对于刷表法来说则是当前层和下一层)。当当前层计算完毕后，上一层就可以被丢弃了，怎么丢弃呢？其实我们只需要替换一下指针或者引用即可。最简单的办法就是用一个 2 层数组去存储，一层下标为 0，另一层为 1.那么你只需要这么做

1.  在初始化数组的时候，初始化层数为 2。
2. 把原来的下标从 [i] 变成 [i&1] 
3. 对于刷表法来说，如果得到下标 i 层的结果后，需要把 [(i+1) & 1] 层的数据清掉。

下面是刷表法的代码例子：

```cpp
int res[2][MAXK];                                     //注意第一维只有 2
for (int i = 0; i<N; i++) {
  memset(res[(i+1)&1], 63, sizeof(res[0]));           //清除下一层的数据
  for (int j = 0; j<=K; j++) {                        //遍历所有状态
    int ni = i + 1;                                   //得到下一层的下标
    int nj, nres = DPTransition(res[i&1][j], ???);    //得到下一层的参数以及结果
    if (res[ni&1][nj] > nres)                         //松弛
      res[ni&1][nj] = nres;                           
  }
}
```

这种做法可以有效减少空间复杂度 O(N) 次，如果 sizeof(res) 减少到不超过几兆字节，那么由于缓存友好的内存访问，速度也会提升。

有时候你需要多存几层，如果你的状态转移依赖前面 k 层的数据的话，那么你可以只存 k 层的数据，用 mod k 来表示新的下标。

这个办法有一个问题，在最优解问题中，这种办法不好恢复路径。你可以得到最终的结果，但是不能得到解决方案。为了恢复结果，你通常需要存储所有的中间方案。

当然，这里有一个比较 trick 的办法可以找到方案，并且不用存所有的结果。路径可以使用分治这种办法去恢复。将层分成 2 部分，并且选择下标 m 作为中间层。那么对于原来的 DP 的结果 (i, A) → R，要变成 (i, A) → R, mA. mA 为在第 m 层依赖的状态。我们来看看具体怎么做：

1. 在 DP 结束后，我们能得到最后一层的结果，即 R, mA。那么现在这个问题就变成了我们要恢复(m, mA)的方案。
2. mA 状态的结果可以根据 DP 计算得到。

我们现在得到了最终的状态以及中间层 m 的状态。那么将层分成两部分，根据上述方法递归去计算。将最终结果作为右半边的答案，中间 m 的结果作为左半边答案。这个方法需要额外 O(log(N)) 的复杂度，因为每一层被额外计算了 log(N) 次。如果有其他参数单调的话(比如(i, A) 到 (i + 1, B), 满足 A ≤ B) ，那么参数的范围也可以作为递归的参数。这种方式复杂度基本不会增加。

## 预处理

有时候预处理一些东西会使得 DP 简单，而通常预处理也是一些简单 DP。

一些组合问题通常需要预处理一些二项式系数。你可以预处理一些前缀和，当需要计算区间和时就可以用 O(1) 的时间去计算。你也可以预处理一些数的 k 次幂。

通常预处理都是在真正 DP 之前去做，但你也可以在 DP 的过程来做一些预处理。比如，现在你的状态为 (a, b) → R，你需要计算另一个状态 (a, k) → S，S 的含义为所有 R(a, b)(b < k) 的和。这个不好在 DP 之前去做，因为它依赖 DP 的值。但是你可以在 DP 的过程去做这个东西，来使得计算 S 更快。

## 旋转最优解问题

假设现在有一个求最大问题，它的状态为 (W, A) → R，W 是一部分东西的权重，A 是其他参数，R是最大值。[[无限背包]](https://en.wikipedia.org/wiki/Knapsack_problem#Unbounded_knapsack_problem) 就是一个类似的问题。

我们现在来思考一个问题：如果我们对于每个子状态只增加它的 w 而不改变其他参数，那么结果就会更糟糕。更糟糕意味着这些增加 w 后的状态一定会被丢弃，因为之前的状态的结果更好。对于 R，同样的说法也是对的：即只增加 R，而不改变其他的参数，结果会更好。对于无限背包这个问题来说，如果我们有一些部分解，其他的解的 W 更大，而 R 更小，那么它肯定比当前解更糟糕，所以就没必要去计算它了。

这种属性可以让我们来旋转 DP：(R, A) → W ，即 R 是部分解的答案，A 是额外的参数，而 W 是达到部分解 R 所需要最小的权重。对于无限背包问题来说，我们尝试用最少的权重去得到每个部分解 R。旋转 DP 就是这样，怎么得到最后的答案呢，和往常一样，遍历所有的 (R, A) → W，选择一个 W 在范围内的最大的 R 即可。

为了更好的理解这个技巧呢，可以尝试想象一个具有 (W, R) 坐标系的网格，W 是横坐标，R 是纵坐标。一般的 DP 根据对于每个横坐标，存最高点的下标。而旋转 DP 是对于每个纵坐标，存最左边的下标。请注意，如果最开始说的条件不成立的话，旋转 DP 的结果就不对。

当 R 的范围远小于 W 时，旋转 DP 就很有用。状态个数从 O(WA) 变成了 O(RA)。比如考虑 01 背包问题，如果它有任意正整数的权重以及价值，那么旋转 DP 没有意义。但旋转 DP可以用于创建完全多项式逼近方案，该方案可以以不超过任意阈值的相对误差逼近正确答案。这个想法是首先将所有的价值除以一个 eps，然后四舍五入到一个最近的整数。然后根据状态(k, R) → W 去解决问题，k 是已经处理过的物品下标，R 是物品的价值，而 W 是需要的最小权重。注意你不能以同样的方式去缩小 W 的范围，因为这样做之后得到的方案可能会违反背包的大小约束。

## 通过矩阵快速幂加速

这个技巧用于处理有层关系的组合 DP 方案。设状态域为 (i, A) → R 而 R(i + 1, A) = sum(R(i, B) * C(B)) 就可以用这个技巧。

我们可以创建一个数组 V(i) = (R(i, A1), R(i, A2), ... R(i, Ak))，Aj 表示 A 这个参数所有可能的值，根据状态转移我们可以写成一个矩阵乘法 V(i + 1) = M * V(i)，M 是转移矩阵，结果通常为最后一层的结果。所以我们需要计算 V(N) = M ^ N * V(0)

那么 DP 的结果为 V(0) 和 M 的 N 次幂的乘积，如果我们用朴素的矩阵乘法的话，它的时间复杂度为 O(N * A ^ 2)。更准确的说是 O(N * Z) ，Z 为 M 元素的大小。而我们用[矩阵快速幂](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)的话， M^N 可以用 O(log(N)) 就可以算完。当矩阵幂算完，我们还要乘以 V(0)，总共的复杂度为 O(A^3 * log(N)) ，当 A 很小(不超过 200) 而 N 很大(1e9)时，就可以用这种方法。

## 使用复杂的数据结构或者算法

有时候 DP 的方法可以用复杂度数据结构或者算法去优化，比如二分，线段树(最小，最大，求和)，二分搜索树(map)。如果你想做出 Div1 的 1000 个 DP题的话，最好要学习一下这些东西。

比如，对于求[最长上升子序列](https://en.wikipedia.org/wiki/Longest_increasing_subsequence)，DP 的方法可以用可以查询动态区间最小值的数据结构，或者二分去加速，使得复杂度变成 O(Nlog(N))。