# 刷表法和填表法
# 刷表法

含义： 由已知点的状态去更新其他点的状态

以求 [$LCS$ (最长公共子序列)](https://leetcode-cn.com/problems/longest-common-subsequence/)举例， 现在有两种写法。

设当前的两个字符串为 $a,b$

1. 如果 $a, b$ 下标从 $0$ 开始, 现在有两种方式进行 $dp$。
    - $dp[i][j]$ 表示下标为 $i,j$ 时的最长的 $LCS$, 在这种情况下需要先预处理出 $dp[0][j]$ 和 $dp[i][0]$ 的值，因为这两种状态无法从其他状态转过来。$i \in [0, len_a - 1], j \in [0, len_b - 1]$
    
    ```cpp
    class Solution {
    public:
        int longestCommonSubsequence(string a, string b) {
            int len_a = a.size();
            int len_b = b.size();
            vector< vector< int > > dp(len_a, vector< int >(len_b, -1));
            
            for (int i = 0; i < len_a; i++) {
                if (a[i] == b[0]) {
                    dp[i][0] = 1;
                } else {
                    dp[i][0] = 0;
                }
            }
            for (int i = 0; i < len_b; i++) {
                if (a[0] == b[i]) {
                    dp[0][i] = 1;
                } else {
                    dp[0][i] = 0;
                }
            }
            
            for (int i = 0; i < len_a; i++) {
                for (int j = 0; j < len_b; j++) {
                    if (dp[i][j] == -1) continue;
                    if (i + 1 < len_a) {
                        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                    }
                    if (j + 1 < len_b) {
                        dp[i][j + 1] = max(dp[i][j + 1], dp[i][j]);
                    }
                    
                    if (i + 1 < len_a && j + 1 < len_b && a[i + 1] == b[j + 1]) {
                        dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 1);
                    }
                }
            }
            return dp[len_a - 1][len_b - 1];
        }
    };
    ```
    
    - $dp[i][j]$ 表示长度为 $i, j$ 时的最长的 $LCS$，在这种情况下，只需要初始化 $dp[0][0]$ 就行了，$i \in [0, len_a], j \in [0, len_b]$。
    
    ```cpp
    class Solution {
    public:
        int longestCommonSubsequence(string a, string b) {
            int len_a = a.size();
            int len_b = b.size();
            vector< vector< int > > dp(len_a + 1, vector< int >(len_b + 1, -1));
            
            dp[0][0] = 0;
            
            for (int i = 0; i <= len_a; i++) {
                for (int j = 0; j <= len_b; j++) {
                    if (dp[i][j] == -1) continue;
                    if (i + 1 <= len_a) {
                        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                    }
                    if (j + 1 <= len_b) {
                        dp[i][j + 1] = max(dp[i][j + 1], dp[i][j]);
                    }
                    
                    if (i < len_a && j < len_b && a[i] == b[j]) {
                        dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 1);
                    }
                }
            }
            return dp[len_a][len_b];
        }
    };
    ```
    
    1. 综上，最好选择第 2 种方式，比较简单, 代码不重复。
2. 如果 $a, b$ 下标从 1 开始
    1. $dp[i][j]$ 表示下标为 $i, j$ 时的最长的 $LCS$，在这种情况下只需要预处理 $dp[0][0]$ 就行。$i \in [0, len_a], j \in [0, len_b]$。
    2. $dp[i][j]$ 表示长度为 $i, j$ 时的最长的 $LCS$，在这种情况下只需要预处理 $dp[0][0]$ 就行。$i \in [0, len_a], j \in [0, len_b]$。 
    
    ```cpp
    class Solution {
    public:
        int longestCommonSubsequence(string a, string b) {
            int len_a = a.size();
            int len_b = b.size();
            a = " " + a;
            b = " " + b;
            vector< vector< int > > dp(len_a + 1, vector< int >(len_b + 1, -1));
            
            dp[0][0] = 0;
            
            for (int i = 0; i <= len_a; i++) {
                for (int j = 0; j <= len_b; j++) {
                    if (dp[i][j] == -1) continue;
                    if (i + 1 <= len_a) {
                        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                    }
                    if (j + 1 <= len_b) {
                        dp[i][j + 1] = max(dp[i][j + 1], dp[i][j]);
                    }
                    
                    if (i + 1 <= len_a && j + 1 <= len_b && a[i + 1] == b[j + 1]) {
                        dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 1);
                    }
                }
            }
            return dp[len_a][len_b];
        }
    };
    ```
    
    1. 综上，其实这个时候下标和长度的值是一模一样的，所以选哪个都无所谓。
    

综上，下标还是从 1 开始好。

# 填表法

含义：通过遍历未知点，然后根据已知点去推导出这个点的结果。

以求 [$LCS$ (最长公共子序列)](https://leetcode-cn.com/problems/longest-common-subsequence/)举例， 现在有两种写法。

设当前的两个字符串为 $a,b$

1. 如果 $a, b$ 下标从 $0$ 开始, 现在有两种方式进行 $dp$。
    - $dp[i][j]$ 表示下标为 $i,j$ 时的最长的 $LCS$, 在这种情况下需要特判 $i$ 为 0 和 $j$ 为 0，因为这两种状态无法从其他状态转过来。$i \in [0, len_a - 1], j \in [0, len_b - 1]$
        
        ```cpp
        class Solution {
        public:
            int longestCommonSubsequence(string a, string b) {
                int len_a = a.size();
                int len_b = b.size();
                vector< vector< int > > dp(len_a, vector< int >(len_b, 0));
                for (int i = 0; i < len_a; i++) {
                    for (int j = 0; j < len_b; j++) {
                        if (i - 1 >= 0) {
                            dp[i][j] = max(dp[i][j], dp[i - 1][j]);
                        }
                        if (j - 1 >= 0) {
                            dp[i][j] = max(dp[i][j], dp[i][j - 1]);
                        }
                        if (a[i] == b[j]) {
                            if (i - 1 >= 0 && j - 1 >= 0)
                                dp[i][j] =max(dp[i][j], dp[i - 1][j - 1] + 1);
                            else dp[i][j] = 1;
                        }
                    }
                }
                return dp[len_a - 1][len_b - 1];
            }
        };
        ```
        
    - $dp[i][j]$ 表示长度为 $i, j$ 时的最长的 $LCS$，在这种情况下，只需要初始化 $dp[0][0]$ 就行了，并且不需要特判一些边界。$i \in [1, len_a], j \in [1, len_b]$。
        
        ```cpp
        class Solution {
        public:
            int longestCommonSubsequence(string a, string b) {
                int len_a = a.size();
                int len_b = b.size();
                vector< vector< int > > dp(len_a + 1, vector< int >(len_b + 1, 0));
                for (int i = 1; i <= len_a; i++) {
                    for (int j = 1; j <= len_b; j++) {
                        dp[i][j] = max(dp[i][j], dp[i - 1][j]);
                        dp[i][j] = max(dp[i][j], dp[i][j - 1]);
                        if (a[i - 1] == b[j - 1]) {
                            dp[i][j] =max(dp[i][j], dp[i - 1][j - 1] + 1);
                        }
                    }
                }
                return dp[len_a][len_b];
            }
        };
        ```
        
2. 如果 $a, b$ 下标从 1 开始。
    - $dp[i][j]$ 表示下标为 $i, j$ 时的最长的 $LCS$，在这种情况下只需要预处理 $dp[0][0]$ 就行。$i \in [0, len_a], j \in [0, len_b]$。
    - $dp[i][j]$ 表示长度为 $i, j$ 时的最长的 $LCS$，在这种情况下只需要预处理 $dp[0][0]$ 就行。$i \in [0, len_a], j \in [0, len_b]$。
        
        ```cpp
        class Solution {
        public:
            int longestCommonSubsequence(string a, string b) {
                int len_a = a.size();
                int len_b = b.size();
                a = " " + a;
                b = " " + b;
                vector< vector< int > > dp(len_a + 1, vector< int >(len_b + 1, 0));
                for (int i = 1; i <= len_a; i++) {
                    for (int j = 1; j <= len_b; j++) {
                        dp[i][j] = max(dp[i][j], dp[i - 1][j]);
                        dp[i][j] = max(dp[i][j], dp[i][j - 1]);
                        if (a[i] == b[j]) {
                            dp[i][j] =max(dp[i][j], dp[i - 1][j - 1] + 1);
                        }
                    }
                }
                return dp[len_a][len_b];
            }
        };
        ```
        

大部分情况下两者都行，主要是要考虑下标，一般情况下，预留一个下标 0 位置写起来更方便，既不需要特判 0 位置，也不需要进行预处理，并且代码更短。所以存的时候从 1 开始我感觉更方便。

有的情况下只能用其中的一个方法。下面列一下只能用一种方法的题单。

# 题单

## 刷表法

- [https://codeforces.com/problemset/problem/346/B](https://codeforces.com/problemset/problem/346/B)