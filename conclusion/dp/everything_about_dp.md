# Everything About Dynamic Programming
注：本文为该篇 [blog](https://codeforces.com/blog/entry/43256) 的译文

**我在 topcoder 的论坛发现了一些有关 dp 很好的材料，所以我写下了这篇博客**

![image.png](https://s2.loli.net/2022/01/07/ZWbR5mrcetXBkVy.png)

# Problem
在 SRM 的题目中，大约有 25% 的问题带有 dp 的 tag。出题人很喜欢出有关 dp 的题目，因为每个 dp 问题在某种意义上都是原创的。所以在算法竞赛中，你必须掌握 dp 的知识。

学习 dp 的最简单的方法就是举例子，本篇文章涵盖了一些 dp 的例子，但对于初学者来说，建议先看其他的 dp 入门教程，推荐 [From novice to advanced](http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=dynProg)。本篇博客的目的是介绍 dp 的各个方面。

# Solution
## 入门(硬币问题)
什么是 dp 呢，它可以被描述成一个依赖于**初始状态**，**递推公式或者连续状态之间的关系**的算法。一个状态的问题可以表示成一个子解决方案。初始状态依赖于给定的输入，然后状态一个接着一个被求出，直到所有的状态都被求解完毕。

让我们来看看一个非常简单的问题，有 n 个硬币，他们的重量为 W1, W2, W3 ..., Wn。给出一个总和 S，要求使用尽可能少的硬币，他们的重量和为 S(每个硬币都有无穷个)，如果他们不可能构成 S，则直接返回。这个问题是著名的无界背包问题的一个例子。对于这个题的状态，我们可以定义为 (P) -> k，表示部分和 P 的解决方案，P 不超过 S，k 是得到重量 P 时需要的最少硬币个数。

因此这个题目的初始状态为 (0)，然后根据之前的已知解去求解后面的解，在这个问题里，状态 (Q) 先于状态 (P) 意味着 Q 小于 P，因此 (Q) 的结果也小于 (P) 的结果。一开始我们的状态为 (0)，然后求出 (P1), (P2), (P3) 等等状态的结果，最终求出 (S) 的结果。这里有一个有关 dp 比较重要的性质 - 一个状态一定要等它的所有前继状态求解完后才会进行求解。

最后但同样重要的是，如何找到状态之间的关系。对于简单问题来说，状态的关系很容易找到，但是对于复杂的问题来说，我们需要做一些额外的操作。我们继续考虑上面说的问题，如果 Q + Wi = P，那么 (P) 状态可以由 (Q) 状态加上一枚 Wi 得来。那么显然 P 状态是由有限个状态递推而来的，而 (P) 是由 (Qi) + 1 并取最小值得来的。

如何用代码实现呢？ DP 的结果通常用数组去存储，在我们的例子中 `mink[0...S]` 表示状态的结果，换句话说 `mink[P] = k` 表示状态 P 的结果。我们根据某种顺序来循环计算，下面的代码包含本题的递推式，数据表，以及结果。

```cpp
/* 状态转移式:
  {k[0] = 0;
  {k[P] = min_i (k[P-Wi] + 1);   (for Wi <= P)
*/
/* 对于输入: S=11, n=3, W = {1,3,5}
   DP 结果表:
  P = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11
  ------+--+--+--+--+--+--+--+--+--+--+--
  k = 0 |1 |2 |1 |2 |1 |2 |3 |2 |3 |2 |3
*/
int n, S;                                        //n: 硬币的个数, S: 希望得到的重量
int wgt[MAXN];                                   //硬币的重量数组: {1, 3, 5};
int mink[MAXW];                                  //DP 的结果 k;
 
  mink[0] = 0;                                   //初始化 0
  for (int P = 1; P<=S; P++) {                   //遍历所有的状态
    int minres = 1000000000;                    
    for (int i = 0; i<n; i++) if (wgt[i] <= P) { // 假设硬币 i 为最后一个硬币 
      int tres = mink[P - wgt[i]] + 1;           //硬币个数为前者 + 1
      if (minres > tres) minres = tres;          //选择最小的硬币个数
    }
    mink[P] = minres;                            //把结果存到 mink 里
  }
  int answer = mink[S];                          // 整个问题的答案为 mink[S]
```

