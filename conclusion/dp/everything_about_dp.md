# Everything About Dynamic Programming
注：本文为该篇 [blog](https://codeforces.com/blog/entry/43256) 的译文

**我在 topcoder 的论坛发现了一些有关 dp 很好的材料，所以我写下了这篇博客**

![image.png](https://s2.loli.net/2022/01/07/ZWbR5mrcetXBkVy.png)

# Problem
在 SRM 的题目中，大约有 25% 的问题带有 dp 的 tag。出题人很喜欢出有关 dp 的题目，因为每个 dp 问题在某种意义上都是原创的。所以在算法竞赛中，你必须掌握 dp 的知识。

学习 dp 的最简单的方法就是举例子，本篇文章涵盖了一些 dp 的例子，但对于初学者来说，建议先看其他的 dp 入门教程，推荐 [From novice to advanced](http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=dynProg)。本篇博客的目的是介绍 dp 的各个方面。

# Solution
## 入门(硬币问题)
什么是 dp 呢，它可以被描述成一个依赖于**初始状态**，**递推公式或者连续状态之间的关系**的算法。一个状态的答案可以表示成一个子解决方案。初始状态依赖于给定的输入，然后状态一个接着一个被求出，直到所有的状态都被求解完毕。

让我们来看看一个非常简单的问题，有 n 个硬币，他们的重量为 W1, W2, W3 ..., Wn。给出一个总和 S，要求使用尽可能少的硬币，他们的重量和为 S(每个硬币都有无穷个)，如果他们不可能构成 S，则直接返回。这个问题是著名的无穷背包问题的一个例子。对于这个题的状态，我们可以定义为 (P) -> k，表示部分和 P 的解决方案，P 不超过 S，k 是得到重量 P 时需要的最少硬币个数。

因此这个题目的初始状态为 (0)，然后根据之前的已知解去求解后面的解，在这个问题里，状态 (Q) 先于状态 (P) 意味着 Q 小于 P，显然 (Q) 的结果也小于 (P) 的结果。一开始我们的状态为 (0)，然后求出 (P1), (P2), (P3) 等等状态的结果，最终求出 (S) 的结果。这里有一个有关 dp 比较重要的性质 - 一个状态一定要等它的所有前继状态求解完后才会进行求解。

最后但同样重要的是，如何找到状态之间的关系。对于简单问题来说，状态的关系很容易找到，但是对于复杂的问题来说，我们需要做一些额外的操作。我们继续考虑上面说的问题，如果 Q + Wi = P，那么 (P) 状态可以由 (Q) 状态加上一枚 Wi 得来。那么显然 P 状态是由有限个状态递推而来的，而 (P) 是由 (Qi) + 1 并取最小值得来的。

如何用代码实现呢？ DP 的结果通常用数组去存储，在我们的例子中 `mink[0...S]` 表示状态的结果，换句话说 `mink[P] = k` 表示状态 P 的结果。我们根据某种顺序来循环计算，下面的代码包含本题的递推式，数据表，以及结果。

```cpp
/* 状态转移式:
  {k[0] = 0;
  {k[P] = min_i (k[P-Wi] + 1);   (for Wi <= P)
*/
/* 对于输入: S=11, n=3, W = {1,3,5}
   DP 结果表:
  P = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11
  ------+--+--+--+--+--+--+--+--+--+--+--
  k = 0 |1 |2 |1 |2 |1 |2 |3 |2 |3 |2 |3
*/
int n, S;                                        //n: 硬币的个数, S: 希望得到的重量
int wgt[MAXN];                                   //硬币的重量数组: {1, 3, 5};
int mink[MAXW];                                  //DP 的结果 k;
 
  mink[0] = 0;                                   //初始化 0
  for (int P = 1; P<=S; P++) {                   //遍历所有的状态
    int minres = 1000000000;                    
    for (int i = 0; i<n; i++) if (wgt[i] <= P) { // 假设硬币 i 为最后一个硬币 
      int tres = mink[P - wgt[i]] + 1;           //硬币个数为前者 + 1
      if (minres > tres) minres = tres;          //选择最小的硬币个数
    }
    mink[P] = minres;                            //把结果存到 mink 里
  }
  int answer = mink[S];                          // 整个问题的答案为 mink[S]
```

## 入门(LCS 问题)
考虑另一个问题，给出 2 个单词，找到他们的最长共同子序列(longest common subsequence)，比如两个单词 "quetzalcoatl" 和 "tezcatlipoca"，它们的 LCS 为 "ezaloa"

为了解决这个问题，我们引入它的子问题，给出第一个单词的前缀和第二个单词的前缀，找到它们的 LCS。设第一个单词的前缀的长度为 i，第二个单词的前缀的长度为 j，那么状态可表示为 (i, j) -> L,解决方案为从 (0, 0) 开始考虑，然后依次往它后面加字符去计算该状态的结果，直到 (n1, n2) 被计算。

接下来，我们分析一下它的递推式，我们用 L[i, j] 表示 DP 的结果。显然，如果其中一个的前缀为空，那么 LCS 一定为 0. 则 L[i, 0] = L[0, j] = 0。当 i 和 j 都为正数时，我们需要考虑一下情况。
1. 第一个单词的最后一个字符没有被使用，所以它可以从子序列中删掉，相应的转移式子为 L[i, j] = L[i - 1, j]
2. 第二个单词的最后一个字符没有被使用，所以它可以从子序列中删掉，相应的转移式子为 L[i, j] = L[i, j - 1]
3. 两个单词的最后一个字符都被使用，当然，它们肯定是要相等的。那么递推式为 L[i, j] = L[i - 1, j - 1] + 1

对于上述 3 种情况，我们取结果的最大值。

实施方面，DP 的结果存到一个二维数组里，我们可以用两层循环去计算该结果，而循环的顺序是一定要非递减的，因为状态(i, j)依赖 (i - 1, j)，(i, j - 1), (i - 1, j - 1)

```cpp
/* 递推式
  {L[i,0] = L[0,j] = 0;
  |            {L[i-1,j],
  {L[i,j] = max|L[i,j-1],
               {L[i-1,j-1]+1   (只有最后一个相等的时候才会有这个转移)
*/
/* 结果:
   S|    t  e  z  c  a  t  l  i  p  o  c  a 
T ji| 0  1  2  3  4  5  6  7  8  9 10 11 12
----+--------------------------------------
  0 | 0  0  0  0  0  0  0  0  0  0  0  0  0 
q 1 | 0  0  0  0  0  0  0  0  0  0  0  0  0 
u 2 | 0  0  0  0  0  0  0  0  0  0  0  0  0 
e 3 | 0  0  1  1  1  1  1  1  1  1  1  1  1 
t 4 | 0  1  1  1  1  1  2  2  2  2  2  2  2 
z 5 | 0  1  1  2  2  2  2  2  2  2  2  2  2 
a 6 | 0  1  1  2  2  3  3  3  3  3  3  3  3 
l 7 | 0  1  1  2  2  3  3  4  4  4  4  4  4 
c 8 | 0  1  1  2  3  3  3  4  4  4  4  5  5 
o 9 | 0  1  1  2  3  3  3  4  4  4  5  5  5 
a 10| 0  1  1  2  3  4  4  4  4  4  5  5  6 
t 11| 0  1  1  2  3  4  5  5  5  5  5  5  6 
l 12| 0  1  1  2  3  4  5  6  6  6  6  6  6 
*/
int n1, n2;                                              // 单词的长度
char str1[1024], str2[1024];                             // 单词
int lcs[1024][1024];                                     // DP 结果
 
  for (int i = 0; i<=n1; i++)                            //遍历所有的状态 (i,j)
    for (int j = 0; j<=n2; j++) {                        
      if (i == 0 || j == 0)
        lcs[i][j] = 0;                                   // DP 最初的状态
      else {
        lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]);       //case 1 和 case 2
        if (str1[i-1] == str2[j-1])
          lcs[i][j] = max(lcs[i][j], lcs[i-1][j-1] + 1); //case 3
      }
    }
  int answer = lcs[n1][n2];

```

## 讨论
### 与记忆化的比较
有另一项技巧，叫做记忆化，会在后面的”优化递归方案“讲到，记忆化和后项 DP 非常相似，两种方法都根据状态转移解决问题，一些状态的结果取决于给定的初始值，其他的状态结果根据它之前的状态的结果。DP 根据 coder 定义的顺序去遍历状态，并且不会重复计算一个状态 2 次。记忆化不会计算那些没有必要的状态 - 它是一个懒惰算法，只有这个状态会影响结果的时候才会被计算，下面是记忆化的一些优点和缺点：
1. +写法简单
2. +不用显示的写出状态转移顺序
3. +只会计算有用的状态
4. -只能用于后项 DP
5. -比普通的 DP 慢(常数大)

大多数 DP 的问题可以分为两类：优化问题和组合问题。优化问题是让你给出一个可行解，使得结果最小或者最大。而组合问题是让你算出某种东西的个数或者概率。让我们仔细研究这些问题。