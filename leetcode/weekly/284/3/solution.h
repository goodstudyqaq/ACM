/*
Code generated by https://github.com/goodStudyTnT/leetcode-tester
*/

#if __has_include("../../utils/cpp/help.h")
#include "../../utils/cpp/help.h"
#endif

struct Edge {
    int u, v, nxt;
    // 其他信息 如权重等。。
    int w;
    // extra_info
};
vector<Edge> edges;
vector<int> head;
int ecnt;

void init(int n, int m) {
    head.resize(n);
    for (int i = 0; i < n; i++) {
        head[i] = -1;
    }
    edges.resize(m);
    ecnt = 0;
}

void add_edge(int u, int v, int w) {
    edges[ecnt] = (Edge){u, v, head[u], w};
    head[u] = ecnt++;
}

struct HeapNode {
    long long d;
    int u;
    bool operator<(const HeapNode& rhs) const {
        return d > rhs.d;
    }
};
vector<bool> done;
vector<long long> d;
const long long inf = 0x3f3f3f3f3f3f;
void dijkstra(int s, int n) {
    priority_queue<HeapNode> Q;
    d.clear(), d.resize(n + 1, inf);
    d[s] = 0;
    done.clear(), done.resize(n + 1, 0);
    Q.push((HeapNode){0, s});
    while (!Q.empty()) {
        HeapNode x = Q.top();
        Q.pop();
        int u = x.u;
        if (done[u]) continue;
        done[u] = true;
        for (int i = head[u]; ~i; i = edges[i].nxt) {
            Edge& e = edges[i];
            if (d[e.v] > d[u] + e.w) {
                d[e.v] = d[u] + e.w;
                Q.push((HeapNode){d[e.v], e.v});
            }
        }
    }
};

class Solution {
   public:
    vector<long long> d1, d2, d3;

    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {
        int m = edges.size();
        init(n, m);
        for (int i = 0; i < m; i++) {
            int u = edges[i][0], v = edges[i][1], w = edges[i][2];
            add_edge(u, v, w);
        }

        d1.resize(n);
        d2.resize(n);
        d3.resize(n);

        dijkstra(src1, n);
        for (int i = 0; i < n; i++) {
            d1[i] = d[i];
        }
        dijkstra(src2, n);
        for (int i = 0; i < n; i++) {
            d2[i] = d[i];
        }
        init(n, m);
        for (int i = 0; i < m; i++) {
            int u = edges[i][0], v = edges[i][1], w = edges[i][2];
            add_edge(v, u, w);
        }
        dijkstra(dest, n);
        for (int i = 0; i < n; i++) {
            d3[i] = d[i];
        }

        long long res = inf;
        for (int i = 0; i < n; i++) {
            res = min(res, d1[i] + d2[i] + d3[i]);
        }
        if (res >= inf) res = -1;
        return res;
    }
};