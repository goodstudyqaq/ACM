/*
Code generated by https://github.com/goodStudyTnT/leetcode-tester
*/

#if __has_include("../../utils/cpp/help.h")
#include "../../utils/cpp/help.h"
#endif

#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif
//对于二分图类型的比较高效
typedef long long ll;
const int maxn = 300;
const int maxm = 10050;
const long long inf = 3e11;
struct Edge {
    long long to, next, cap, flow, cost;
    Edge(long long _t, ll _next, ll _cap, ll _flow, ll _cost) : to(_t), next(_next), cap(_cap), flow(_flow), cost(_cost) {}
    Edge() {}
} edges[maxm];
struct ZKW_MinCostMaxFlow {
    ll head[maxn], tot;
    ll cur[maxn];
    ll dis[maxn];
    bool vis[maxn];
    ll ss, tt, N;  //源点,汇点,和点的总个数(编号是0到N-1),不需要额外赋值,调用会直接赋值。
    long long min_cost, max_flow;
    void init() {
        tot = 0;
        memset(head, -1, sizeof(head));
    }
    void addedge(ll u, ll v, ll cap, ll cost) {
        edges[tot] = Edge(v, head[u], cap, 0, cost);
        head[u] = tot++;
        edges[tot] = Edge(u, head[v], 0, 0, -cost);
        head[v] = tot++;
    }
    ll aug(int u, ll flow) {
        if (u == tt) return flow;
        vis[u] = 1;
        for (int i = cur[u]; ~i; i = edges[i].next) {
            int v = edges[i].to;
            if (edges[i].cap > edges[i].flow && !vis[v] && dis[u] == dis[v] + edges[i].cost) {
                ll tmp = aug(v, min(flow, edges[i].cap - edges[i].flow));
                edges[i].flow += tmp;
                edges[i ^ 1].flow -= tmp;
                cur[u] = i;
                if (tmp) return tmp;
            }
        }
        return 0;
    }
    bool modify_label() {
        ll d = inf;
        for (int u = 0; u < N; u++)
            if (vis[u])
                for (int i = head[u]; ~i; i = edges[i].next) {
                    int v = edges[i].to;
                    if (edges[i].cap > edges[i].flow && !vis[v])
                        d = min(d, dis[v] + edges[i].cost - dis[u]);
                }
        if (d == inf) return false;
        for (int i = 0; i < N; i++)
            if (vis[i]) {
                vis[i] = false;
                dis[i] += d;
            }
        return true;
    }
    pair<ll, ll> mincostmaxflow(int start, int end, int n) {
        ss = start, tt = end, N = n;
        min_cost = max_flow = 0;
        for (int i = 0; i < n; i++) dis[i] = 0;
        while (1) {
            for (int i = 0; i < n; i++) cur[i] = head[i];
            while (1) {
                for (int i = 0; i < n; i++) vis[i] = false;
                ll tmp = aug(ss, inf);
                if (tmp == 0) break;
                max_flow += tmp;
                min_cost += tmp * dis[ss];
            }
            if (!modify_label()) break;
        }
        return make_pair(min_cost, max_flow);
    }
} solve;

class Solution {
   public:
    long long minimumTotalDistance(vector<int>& a, vector<vector<int>>& b) {
        int n = a.size();
        int m = b.size();
        solve.init();
        // 0 ~ n + m - 1
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int d = abs(a[i] - b[j][0]);
                solve.addedge(i, j + n, 1, d);
            }
        }
        int s = n + m, t = n + m + 1;
        int N = n + m + 2;
        for (int i = 0; i < n; i++) {
            solve.addedge(s, i, 1, 0);
        }

        for (int i = 0; i < m; i++) {
            solve.addedge(n + i, t, b[i][1], 0);
        }

        auto res = solve.mincostmaxflow(s, t, N);
        return res.first;
    }
};