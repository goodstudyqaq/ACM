/*
Code generated by https://github.com/goodStudyTnT/leetcode-tester
*/

#if __has_include("../../utils/cpp/help.h")
#include "../../utils/cpp/help.h"
#endif

#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

struct Manacher {
    string s;
    vector<int> Mp;
    Manacher(string &_s) {
        s = "";
        int n = _s.size();
        s += "$";
        s += "#";
        for (int i = 0; i < n; i++) {
            s += _s[i];
            s += "#";
        }
        s += "?";
        int id = 0, mx = 0;
        int l = s.size();
        Mp.resize(l);
        for (int i = 0; i < l - 1; i++) {
            Mp[i] = mx > i ? min(Mp[2 * id - i], mx - i) : 1;
            while (i + Mp[i] < l && i - Mp[i] >= 0 && s[i + Mp[i]] == s[i - Mp[i]]) Mp[i]++;
            if (i + Mp[i] > mx) {
                mx = i + Mp[i];
                id = i;
            }
        }
    }
    Manacher() {}

    int query(int l, int r) {
        // l = r 那么就表示以 l 为中心的最长回文串
        // l + 1 = r 那么就表示以 l 和 r 中间为中心的最长回文串
        // 返回长度
        int idx = (l + 1) * 2;
        if (l != r) {
            idx++;
        }
        int length = Mp[idx];
        return length / 2;
    }
};

class Solution {
   public:
    int maxPalindromes(string s, int k) {
        int n = s.size();
        Manacher ma(s);

        // debug(ma.query(1, 1));
        // debug(ma.query(6, 7));

        vector<int> dp(n, 0);
        vector<int> mx_dp(n, 0);
        int ans = 0;

        for (int i = k - 1; i < n; i++) {
            for (int j = i - k + 1; j >= 0; j--) {
                int len = i - j + 1;
                bool flag = false;
                if (len % 2 == 0) {
                    int mid = (i + j) / 2;
                    int tmp = ma.query(mid, mid + 1);
                    if (tmp >= len / 2) flag = true;

                } else {
                    int mid = (i + j) / 2;
                    int tmp = ma.query(mid, mid);
                    if (tmp >= len / 2 + 1) flag = true;
                }

                if (flag) {
                    int tmp = 1;
                    if (j != 0) {
                        tmp += mx_dp[j - 1];
                    }
                    dp[i] = max(dp[i], tmp);
                    break;
                }
            }
            ans = max(ans, dp[i]);
            mx_dp[i] = dp[i];
            if (i != 0) {
                mx_dp[i] = max(mx_dp[i], mx_dp[i - 1]);
            }
        }
        return ans;
    }
};