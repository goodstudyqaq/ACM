/*
Code generated by https://github.com/goodStudyTnT/leetcode-tester
*/

#if __has_include("../../utils/cpp/help.h")
#include "../../utils/cpp/help.h"
#endif

#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

// 时间复杂度O(n)
const int maxn = 1e6 + 5;
bool is[maxn];
int prm[maxn], id;
// 每个数的最小质因子
int minp[maxn];
void get_prime() {
    /*
    数被筛掉的顺序：3 -> 3^2 -> 2*3^2 -> 2^2 * 3^2
    即从最大的质数去填
    */
    if (id) return;
    int k = 0;
    memset(is, 1, sizeof(is));
    is[0] = is[1] = 0;
    for (int i = 2; i < maxn; ++i) {
        if (is[i]) {
            prm[k++] = i;
            minp[i] = i;
        }
        for (int j = 0; j < k && (i * prm[j] < maxn); ++j) {
            is[i * prm[j]] = 0;
            minp[i * prm[j]] = prm[j];
            if (i % prm[j] == 0) break;
        }
    }
    id = k;
}

class Solution {
   public:
    vector<int> closestPrimes(int left, int right) {
        get_prime();
        int idx = lower_bound(prm, prm + id, left) - prm;

        int idx2 = upper_bound(prm, prm + id, right) - prm;

        if (idx2 - idx <= 1) return {-1, -1};
        int res = 1e9;
        int resl = -1, resr = -1;
        for (int i = idx + 1; i < idx2; i++) {
            int tmp = prm[i] - prm[i - 1];
            if (res > tmp) {
                res = tmp;
                resl = prm[i - 1], resr = prm[i];
                if (res == 2) {
                    return {resl, resr};
                }
            }
        }
        return {resl, resr};
    }
};