/*
Code generated by https://github.com/goodStudyTnT/leetcode-tester
*/

#if __has_include("../../utils/cpp/help.h")
#include "../../utils/cpp/help.h"
#endif

#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

typedef pair<int, int> pii;
typedef pair<pii, int> piii;
class Solution {
   public:
    int minimumObstacles(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, -1));

        deque<piii> Q;
        Q.push_front({{0, 0}, 0});
        d[0][0] = 0;

        int dir[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};
        while (!Q.empty()) {
            auto u = Q.front();
            Q.pop_front();
            if (u.first == make_pair(n - 1, m - 1)) {
                return u.second;
            }
            for (int i = 0; i < 4; i++) {
                int nxt_x = u.first.first + dir[i][0], nxt_y = u.first.second + dir[i][1];
                if (nxt_x >= 0 && nxt_x < n && nxt_y >= 0 && nxt_y < m && d[nxt_x][nxt_y] == -1) {
                    int flag = grid[nxt_x][nxt_y];
                    if (flag) {
                        d[nxt_x][nxt_y] = u.second + 1;
                        Q.push_back({{nxt_x, nxt_y}, d[nxt_x][nxt_y]});
                    } else {
                        d[nxt_x][nxt_y] = u.second;
                        Q.push_front({{nxt_x, nxt_y}, d[nxt_x][nxt_y]});
                    }
                }
            }
        }
    }
};