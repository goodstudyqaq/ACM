/*
Code generated by https://github.com/goodStudyTnT/leetcode-tester
*/

#if __has_include("../../utils/cpp/help.h")
#include "../../utils/cpp/help.h"
#endif

#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

struct DSU2 {
    std::vector<int> f;
    DSU2(int n) : f(n) { std::iota(f.begin(), f.end(), 0); }
    int leader(int x) {
        if (f[x] == x) {
            return x;
        }
        int y = leader(f[x]);
        f[x] = y;
        return f[x];
    }
    bool merge(int a, int b) {
        auto x = leader(a);
        auto y = leader(b);
        if (x == y) {
            return false;
        }
        f[x] = y;
        return true;
    }
};

class Solution {
   public:
    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {
        // vals = {2, 5, 5, 1, 5, 2, 3, 5, 1, 5};
        // edges = {{0, 1}, {2, 1}, {3, 2}, {3, 4}, {3, 5}, {5, 6}, {1, 7}, {8, 4}, {9, 7}};

        int n = vals.size();
        int m = edges.size();
        vector<vector<int>> V(n);
        for (int i = 0; i < m; i++) {
            int u = edges[i][0], v = edges[i][1];
            V[u].push_back(v);
            V[v].push_back(u);
        }

        vector<int> idx(n);
        iota(idx.begin(), idx.end(), 0);
        sort(idx.begin(), idx.end(), [&](int x, int y) {
            return vals[x] < vals[y];
        });

        int now = 0;
        DSU2 dsu(n);
        int res = 0;
        vector<bool> vis(n);
        while (now < n) {
            int go = now;
            while (go < n && vals[idx[now]] == vals[idx[go]]) {
                go++;
            }
            //[now, go)
            for (int i = now; i < go; i++) {
                int u = idx[i];
                vis[u] = 1;
            }
            map<int, int> M;
            for (int i = now; i < go; i++) {
                int u = idx[i];
                for (auto v : V[u]) {
                    if (vis[v]) {
                        dsu.merge(u, v);
                    }
                }
            }
            for (int i = now; i < go; i++) {
                int u = idx[i];
                M[dsu.leader(u)]++;
            }

            for (auto it : M) {
                if (it.second > 1) {
                    debug(it.second);
                    int tmp = (it.second - 1) * it.second / 2;
                    debug(tmp);
                    res += tmp;
                }
            }
            debug(now, go, M, res);
            now = go;
        }
        return res + n;
    }
};