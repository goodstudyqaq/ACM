/*
Code generated by https://github.com/goodStudyTnT/leetcode-tester
*/

#if __has_include("../../utils/cpp/help.h")
#include "../../utils/cpp/help.h"
#endif

#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

class Solution {
   public:
    long long countSubarrays(vector<int>& a, int minK, int maxK) {
        int n = a.size();

        vector<int> num;
        for (int i = 0; i < n; i++) {
            if (a[i] == minK) {
                num.push_back(i);
            }
        }

        vector<int> stk(n);
        int scnt = 0;
        vector<int> l_ge(n);
        // 左边第一个大于等于 a[i] 的下标
        for (int i = 0; i < n; i++) {
            while (scnt > 0 && a[stk[scnt - 1]] < a[i]) {
                scnt--;
            }
            if (scnt == 0) {
                l_ge[i] = -1;
            } else {
                l_ge[i] = stk[scnt - 1];
            }
            stk[scnt++] = i;
        }

        vector<int> r_g(n);
        // 右边第一个大于 a[i] 的下标
        scnt = 0;

        for (int i = n - 1; i >= 0; i--) {
            while (scnt > 0 && a[stk[scnt - 1]] <= a[i]) {
                scnt--;
            }
            if (scnt == 0) {
                r_g[i] = n;
            } else {
                r_g[i] = stk[scnt - 1];
            }
            stk[scnt++] = i;
        }

        vector<int> l_le(n);
        scnt = 0;
        for (int i = 0; i < n; i++) {
            while (scnt > 0 && a[stk[scnt - 1]] > a[i]) {
                scnt--;
            }
            if (scnt == 0) {
                l_le[i] = -1;
            } else {
                l_le[i] = stk[scnt - 1];
            }
            stk[scnt++] = i;
        }

        vector<int> l_l(n);
        scnt = 0;
        for (int i = 0; i < n; i++) {
            while (scnt > 0 && a[stk[scnt - 1]] >= a[i]) {
                scnt--;
            }
            if (scnt == 0) {
                l_l[i] = -1;
            } else {
                l_l[i] = stk[scnt - 1];
            }
            stk[scnt++] = i;
        }

        vector<int> r_l(n);
        scnt = 0;
        for (int i = n - 1; i >= 0; i--) {
            while (scnt > 0 && a[stk[scnt - 1]] >= a[i]) {
                scnt--;
            }
            if (scnt == 0) {
                r_l[i] = n;
            } else {
                r_l[i] = stk[scnt - 1];
            }
            stk[scnt++] = i;
        }

        long long ans = 0;
        const int maxn = 1e6 + 5;
        int now_idx = 0;
        for (int i = 0; i < n; i++) {
            int val = a[i];
            int left = l_ge[i] + 1, right = r_g[i] - 1;
            debug(i, left, right);
            // [left, right]
            long long sub_ans = 0;
            if (a[i] == maxK) {
                if (num.size() && now_idx - 1 < num.size() && now_idx - 1 >= 0) {
                    int the_idx = num[now_idx - 1];
                    // 最近的一个下标
                    if (the_idx >= left) {
                        int left2 = l_l[the_idx] + 1;
                        int right2 = r_l[the_idx] - 1;
                        if (right2 >= i) {
                            debug(i, left2, right2);
                            sub_ans += 1LL * (the_idx - max(left, left2) + 1) * (min(right2, right) - i + 1);
                        }
                    }
                }
                if (num.size() && now_idx < num.size()) {
                    int the_idx = num[now_idx];
                    if (the_idx <= right) {
                        int left2 = l_le[the_idx] + 1;
                        int right2 = r_l[the_idx] - 1;
                        debug(left2, right2);
                        if (left2 <= i) {
                            sub_ans += 1LL * (i - max(left, left2) + 1) * (min(right2, right) - the_idx + 1);
                        }
                    }
                }
            }
            ans += sub_ans;
            debug(i, sub_ans);
            if (a[i] == minK) {
                now_idx++;
            }
        }
        return ans;
    }
};