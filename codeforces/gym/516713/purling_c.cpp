/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠋⠀⠀⠀⡧⠚⠉⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⣰⠀⠀⠐⠀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠁
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡷⠤⠤⢬⡀⠀⢀⣴⡷⠗⠚⣷⡤⠛⠉⠙⠮⡙⡄⠀⣸
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠤⠔⠒⣒⡏⢀⣀⣀⡀⣿⠉⢅⠀⠐⠉⢠⢓⢤⡀⠀⠀⠀⠈⠂⠀⣿
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⠚⠁⠀⢀⣀⣐⣀⠀⠳⡇⠀⠀⠀⠀⠀⠀⢣⠀⡤⠧⢄⡀⠙⡓⢤⠀⠀⠀⠀⣿⢄⠀⠀⢠
⠀⣀⣀⣀⣀⣀⣀⣤⣀⠀⢀⠚⠚⠀⠦⡀⠠⣉⠉⠓⠀⠀⠀⠽⣄⠀⠀⠀⠀⠀⠀⡁⠀⠀⠀⠀⠀⠉⠙⣍⠙⠚⠉⢿⠉⢾
⠀⠈⢦⠠⠖⠂⠀⠀⠀⡳⠉⠁⠀⠀⠀⠀⢢⠀⠓⡀⠀⠀⠀⠀⠀⠑⠦⣒⣀⣀⣴⠜⠙⡛⠲⣀⣀⠀⠀⠁⡙⣄⡀⠘⡀
⠀⠀⠀⠙⢤⡀⠀⠀⣴⠀⠀⡇⠀⠀⠀⠀⠀⠹⡀⠀⢄⠀⠀⢀⠦⢠⠀⠀⠈⣄⠿⡇⢀⢹⠀⠀⠙⣄⣄⣀⠀⠢⠂⠉⢷
⠀⠲⣒⠒⡋⠄⡄⢠⠃⠀⠀⣇⠀⠀⠀⠀⠃⠀⠹⠳⡀⢦⡀⠀⠀⠀⠳⠀⠀⢎⣆⡇⠘⣸⡇⠀⠀⠀⠙⣀⢷⠀⠀⡄⠀⢧
⢤⠀⠀⠓⢤⣤⠤⣼⠀⠀⠀⠸⠀⠀⣄⠀⠀⠀⡀⢳⡉⠙⣞⣀⣄⠀⠀⠻⠀⢇⢘⡮⢢⣦⣧⠀⠀⠀⠀⠈⣯⠹⢦⣧⠀⠀⠳
⠀⣷⠀⠾⡵⣉⠀⣏⠀⠀⠀⠀⠹⠀⠈⠳⠀⠀⠈⣄⡖⠀⠀⣡⣶⢍⣟⠾⢳⢸⠀⠙⠀⡿⣷⣀⣀⣀⠀⡀⢸⠀⠀⠀⠀⠀⠀⠙
⠀⣿⠀⢸⠋⢸⠀⣿⠆⡀⢠⠀⠀⠘⣄⡀⠰⡀⠀⠈⡾⢫⣟⠖⣤⣸⡰⣧⠀⢿⣤⠀⠹⣷⢾⡉⢦⡀
⠀⠘⡦⠏⠀⢸⠀⢿⣦⠈⠀⠀⠀⡠⣅⠳⡀⠻⠆⠀⢹⠀⠈⠀⠈⠻⠿⠁⠀⠈⠀⡂⣇⢿⢦⠀⠦⡀⠀⠛⡭⠀⠀⠀⠀⠀⠀⣠
⠒⣡⢿⠀⠀⠀⡀⠸⡿⡰⠀⠀⡄⠀⢿⠀⠀⣒⣦⣃⠁⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⡟⢹⣆⣯⢿⡢⡀⡉⠉⠀⠀⠀⠀⠀⠀⠀⠙
⠒⠉⠉⣯⠉⠙⢳⢤⡿⠘⡀⢷⠀⠀⣾⠀⣷⢧⠤⢼⠦⢀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢿⠀⣏⢦⠳⢤⣀
⠀⠀⠀⢹⡄⠀⠀⡄⣿⡷⡀⠂⡽⣠⠛⣍⢦⣀⠈⠙⠁⠀⠀⠀⠀⠀⠔⠀⠀⢠⠋⠀⢧⠘⣶⠈⠙⠯⠀⣀⠤⠒⠒⢄
⠀⠀⠀⠀⣿⠀⠀⢻⠃⠀⠈⠀⠉⣄⠙⠋⠃⢻⡟⢮⠀⠀⠀⠀⠀⠀⠀⠀⡴⣁⠖⣩⢞⢦⣝⣟⠛⣉⠝⠊⢉⡀⠀⠀⠈⢄
⠀⠀⠀⠀⠘⣇⠴⢹⢄⠀⠀⠈⠀⠸⡓⠛⢶⡀⣇⠱⡈⠓⡲⡒⠺⡉⠁⠠⣫⢶⣁⠞⠉⠁⣀⣠⣾⠤⡀⠀⣿⢳⣀⡖⠙⢦⢻
⠀⠀⠀⢀⠖⢻⣄⣀⣿⣄⠀⠀⠹⢤⣘⢦⠀⣰⣽⠀⣽⠹⡇⠙⣄⠸⣦⣾⣒⠯⠒⠚⠛⣽⠋⠉⠢⠀⠈⠀⠀⠉⠷⡛⡁⡦⠒⢧
⠀⢀⠞⠀⠀⡟⡴⣚⠿⠑⠗⠄⣀⡇⠀⠀⠀⠳⡇⠀⠿⣀⠷⠒⠉⠀⠈⠙⡄⠀⠀⠀⢠⠷⡀⠀⠀⠀⣰⣄⡄⠀⠀⠙⣦⣾
⡴⠁⠀⠀⠀⡿⣠⢁⠞⣹⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⠀⠀⠀⠳⣀⠀⠀⠀⠀⠈⠙⢿⢝⣯⣍⠒⠐⡛⢓⢤⣯⡆
⠀⠀⠀⠀⠀⠻⡄⠈⠀⡷⠋⠀⠀⠈⠁⡇⠀⠀⠀⠀⠀⡿⠀⠀⠀⠀⠀⠀⣠⢋⠯⢯⠀⠀⡤⢻⠈⡄⠳⠀⣷⡀⠀⡴⡵⣕⣿⡣
⠀⠀⠀⠀⠀⠀⠀⠲⡞⠳⣄⠀⠀⠀⢠⡇⠀⠀⠀⠰⡾⠉⠞⠀⢳⠶⣤⢰⢠⡁⢦⠑⡷⣿⡴⡟⠀⢃⠀⣳⢳⢎⣤⡯⠋⠓⣿⡝
⠀⠀⠀⠀⠀⣠⠚⠉⠳⡀⠈⣷⣄⠀⠈⣻⡀⠀⠀⠀⡏⡅⠀⣤⠉⠑⣬⣿⡟⡈⠀⢹⠭⠥⣿⠥⣽⡭⢓⣉⠧⠳⣿⣿⣟⠲⢤⣷
*/

#include <bits/stdc++.h>
using namespace std;

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, int> pli;
typedef pair<int, ll> pil;
typedef pair<ll, ll> pll;

#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define MSV(X, V) memset((X), V, sizeof((X)))
#define LEN(X) strlen(X + 1)
#define SIZ(X) ((int)X.size())
#define MP make_pair
#define PB push_back
#define EB emplace_back

/* SORT_AND_UNIQUE */

template <class T>
void REV (T *a, int n) {
    reverse (a + 1, a + 1 + n);
}
template <class T>
void SRT (T *a, int n) {
    sort (a + 1, a + 1 + n);
}
template <class T>
int UNI (T *a, int n) {
    sort (a + 1, a + 1 + n);
    return unique (a + 1, a + 1 + n) - (a + 1);
}
template <class T>
int POS (T *a, int n, T v) {
    return lower_bound (a + 1, a + 1 + n, v) - a;
}
template <class T>
int fisrtGe (T *a, int n, T v) {
    return lower_bound (a + 1, a + 1 + n, v) - a;
}
template <class T>
int lastLe (T *a, int n, T v) {
    return upper_bound (a + 1, a + 1 + n, v) - a - 1;
}

/* READ_AND_WRITE */

template <class T>
void _RD (T &x) {
    cin >> x;
}
void _RD (int &x) {
    scanf ("%d", &x);
}
void _RD (uint &x) {
    scanf ("%u", &x);
}
void _RD (ll &x) {
    scanf ("%lld", &x);
}
void _RD (ull &x) {
    scanf ("%llu", &x);
}
void _RD (double &x) {
    scanf ("%lf", &x);
}
void _RD (char &x) {
    scanf (" %c", &x);
}
void _RD (char *x) {
    scanf ("%s", x + 1);
}
template<class T, class U>
void _RD (pair<T, U> &x) {
    _RD (x.first);
    _RD (x.second);
}
void RD() {
}
template <class T, class... U>
void RD (T &head, U &...tail) {
    _RD (head);
    RD (tail...);
}
template <class T>
void RDN (T *a, int n) {
    for (int i = 1; i <= n; ++i)
        _RD (a[i]);
}

template <class T>
void _WT (const T &x) {
    cout << x;
}
void _WT (const int &x) {
    printf ("%d", x);
}
void _WT (const uint &x) {
    printf ("%u", x);
}
void _WT (const ll &x) {
    printf ("%lld", x);
}
void _WT (const ull &x) {
    printf ("%llu", x);
}
void _WT (const double &x) {
    printf ("%.12f", x);
}
void _WT (const char &x) {
    putchar (x);
}
void _WT (const char *x) {
    printf ("%s", x + 1);
}
template <class T, class U>
void _WT (const pair<T, U> &x) {
    _WT (x.first);
    putchar (' ');
    _WT (x.second);
}
void WT() {
}
template <class T, class... U>
void WT (const T &head, const U &...tail) {
    _WT (head);
    putchar (sizeof... (tail) ? ' ' : '\n');
    WT (tail...);
}
template <class T>
void WTN (T *a, int n) {
    for (int i = 1; i <= n; ++i) {
        _WT (a[i]);
        putchar (" \n"[i == n]);
    }
}

template <class T>
void WTV (const vector<T> &x, bool ln = false) {
    WT (x.size());
    for (auto i = x.begin(); i != x.end(); ++i) {
        _WT (*i);
        putchar (ln ? '\n' : ' ');
    }
    if (!ln)
        putchar ('\n');
}

template <typename A, typename B>
string to_string (pair<A, B> p);

template <typename A, typename B, typename C>
string to_string (tuple<A, B, C> p);

template <typename A, typename B, typename C, typename D>
string to_string (tuple<A, B, C, D> p);

string to_string (const string& s) {
    return '"' + s + '"';
}

string to_string (const char* s) {
    return to_string ( (string) s);
}

string to_string (bool b) {
    return (b ? "true" : "false");
}

string to_string (vector<bool> v) {
    bool first = true;
    string res = "{";
    for (int i = 0; i < static_cast<int> (v.size()); i++) {
        if (!first) {
            res += ", ";
        }
        first = false;
        res += to_string (v[i]);
    }
    res += "}";
    return res;
}

template <size_t N>
string to_string (bitset<N> v) {
    string res = "";
    for (size_t i = 0; i < N; i++) {
        res += static_cast<char> ('0' + v[i]);
    }
    return res;
}

template <typename A>
string to_string (A v) {
    bool first = true;
    string res = "{";
    for (const auto& x : v) {
        if (!first) {
            res += ", ";
        }
        first = false;
        res += to_string (x);
    }
    res += "}";
    return res;
}

template <typename A, typename B>
string to_string (pair<A, B> p) {
    return "(" + to_string (p.first) + ", " + to_string (p.second) + ")";
}

template <typename A, typename B, typename C>
string to_string (tuple<A, B, C> p) {
    return "(" + to_string (get<0> (p)) + ", " + to_string (get<1> (p)) + ", " + to_string (get<2> (p)) + ")";
}

template <typename A, typename B, typename C, typename D>
string to_string (tuple<A, B, C, D> p) {
    return "(" + to_string (get<0> (p)) + ", " + to_string (get<1> (p)) + ", " + to_string (get<2> (p)) + ", " + to_string (get<3> (p)) + ")";
}

void debug_out() {
    cerr << endl;
}

template <typename Head, typename... Tail>
void debug_out (Head H, Tail... T) {
    cerr << " " << to_string (H);
    debug_out (T...);
}

#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)

#ifdef LOCAL
#define D1(a)           cerr << #a << " = " << (a) << endl
#define D2(a, b)        cerr << #a << " = " << (a) << ", " << #b << " = " << (b) << endl
#define D3(a, b, c)     cerr << #a << " = " << (a) << ", " << #b << " = " << (b) << ", " \
                             << #c << " = " << (c) << endl
#define D4(a, b, c, d)  cerr << #a << " = " << (a) << ", " << #b << " = " << (b) << ", " \
                             << #c << " = " << (c) << ", " << #d << " = " << (d) << endl
#define ASSERT(x) assert(x)
#else
#define D1(a)
#define D2(a, b)
#define D3(a, b, c)
#define D4(a, b, c, d)
#define ASSERT(x)
#endif

/* CMIN_AND_CMAX */

template <typename T>
void cmin (T &x, T y) {
    if (y < x)
        x = y;
}

template <typename T>
void cmax (T &x, T y) {
    if (y > x)
        x = y;
}

#define TIME chrono::system_clock::now().time_since_epoch().count()

#ifdef LOCAL
int rnd_seed = 19937;
#else
int rnd_seed = TIME;
#endif // LOCAL

mt19937 rnd (rnd_seed);

int rangeRand (int L, int R) {
    int res = (int) ( (1.0 * rnd() / UINT_MAX) * (R - L + 1)) + L;
    return res;
}

//void rangeRandTest() {
//    map<int, int> M;
//    int n = 2000000, L = 1, R = 10;
//    for(int i = 1; i <= n; ++i) {
//        int t = rangeRand(L, R);
//        M[t] += 1;
//    }
//    int minnum = INF, maxnum = -INF;
//    int mincnt = INF, maxcnt = -INF;
//    for(auto i : M) {
//        printf("%d:%.6f%\n", i.first, 100.0 * i.second / n);
//        cmin(minnum, i.first);
//        cmax(maxnum, i.first);
//        cmin(mincnt, i.second);
//        cmax(maxcnt, i.second);
//    }
//    D2(minnum, maxnum);
//    D2(mincnt, maxcnt);
//}


const int INF = 0x3F3F3F3F;
const ll LINF = 0x3F3F3F3F3F3F3F3FLL;
////int MOD = 998244353;
//const int MOD = 1e9 + 7;
///* MOD must be a prime. if not, don't use inv() */
//
//struct ModularIntegers {
//#define mint ModularIntegers
//    int num;
//    mint() {
//        num = 0;
//    }
//    template <typename T>
//    mint (const T& x) {
//        ll tmp = x;
//        if (tmp >= MOD) {
//            if (tmp < (MOD << 1)) tmp -= MOD;
//            else tmp %= MOD;
//        } else if (tmp < 0) {
//            if (tmp >= -MOD) tmp += MOD;
//            else if (tmp %= MOD) tmp += MOD;
//        }
//        num = tmp;
//    }
//    friend mint operator+ (const mint &x, const mint &y) {
//        mint res;
//        res.num = x.num + y.num;
//        if (res.num >= MOD) res.num -= MOD;
//        return move (res);
//    }
//    friend mint operator- (const mint &x, const mint &y) {
//        mint res;
//        res.num = x.num - y.num;
//        if (res.num < 0) res.num += MOD;
//        return move (res);
//    }
//    friend mint operator* (const mint &x, const mint &y) {
//        mint res;
//        res.num = 1LL * x.num * y.num % MOD;
//        return move (res);
//    }
//    friend mint operator/ (const mint &x, const mint &y) {
//        return x * y.inv();
//    }
//    friend bool operator== (const mint &x, const mint &y) {
//        return x.num == y.num;
//    }
//    friend bool operator!= (const mint &x, const mint &y) {
//        return x.num != y.num;
//    }
//    mint operator+() {
//        return +this->num;
//    }
//    mint operator-() {
//        return -this->num;
//    }
//    mint& operator+= (const mint &x) {
//        if ( (this->num += x.num) >= MOD) this->num -= MOD;
//        return *this;
//    }
//    mint& operator-= (const mint &x) {
//        if ( (this->num -= x.num) < 0) this->num += MOD;
//        return *this;
//    }
//    mint& operator*= (const mint &x) {
//        this->num = 1LL * this->num * x.num % MOD;
//        return *this;
//    }
//    mint& operator/= (const mint &x) {
//        this->num = ( (*this) * x.inv()).num;
//        return *this;
//    }
//    mint pow (ll x) const {
//        mint res (1), cur (this->num);
//        for (; x; cur *= cur, x >>= 1)
//            if (x & 1) res *= cur;
//        return res;
//    }
//    mint inv() const {
//        return pow (MOD - 2);
//    }
//    operator int() {
//        return num;
//    }
//    operator uint() {
//        return num;
//    }
//    operator ll() {
//        return num;
//    }
//    operator ull() {
//        return num;
//    }
//#undef mint
//};

//typedef ModularIntegers mint;

//void _RD (mint &x) {
//    scanf ("%d", &x.num);
//}
//void _WT (const mint &x) {
//    printf ("%d", x.num);
//}
//
//struct custom_hash {
//    static uint64_t splitmix64 (uint64_t x) {
//        x ^= x << 13;
//        x ^= x >> 7;
//        x ^= x << 17;
//        return x;
//    }
//    size_t operator () (uint64_t x) const {
//        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); // 时间戳
//        return splitmix64 (x + FIXED_RANDOM);
//    }
//};

/*****************/
/* MY_CODE_BEGIN */

int n;
vector<int> G[100005];
char ans[100005];
int dep[100005];

int dfs (int u, int p) {
//    D2(u, dep[u]);
    int max_dep = u;
    for (int v : G[u]) {
        if (v == p || ans[v] != '?') {
            continue;
        }
        dep[v] = dep[u] + 1;
        int leaf = dfs (v, u);
        if (dep[leaf] > dep[max_dep]) {
            max_dep = leaf;
        }
    }
    return max_dep;
}

pii find_center (int u, int p, int max_dep) {
//    D2 (u, dep[u]);
    if (u == max_dep) {
//        puts ("return!");
//        D2 (0, max_dep);
        pii res = {0, max_dep};
        if (dep[u] == dep[max_dep] / 2) {
            res.first = u;
        }
        return res;
    }
    for (int v : G[u]) {
        if (v == p || ans[v] != '?') {
            continue;
        }
        pii v_res = find_center (v, u, max_dep);
        if (v_res.first != 0) {
            return v_res;
        } else if (v_res.second == 0) {
            continue;
        } else if (dep[u] == dep[max_dep] / 2) {
            v_res.first = u;
        }
//        puts ("return!");
//        D2 (v_res.first, v_res.second);
        return v_res;
    }
    return {0, 0};
}

void write (int u, char ch) {
    ans[u] = ch;
    for (int v : G[u]) {
        if (ans[v] != '?') {
            continue;
        }
        dep[v] = 0;
        int leaf1 = dfs (v, v);
        dep[leaf1] = 0;
        int leaf2 = dfs (leaf1, leaf1);
        int center = find_center (leaf1, leaf1, leaf2).first;
//        D3 (leaf1, leaf2, center);
        write (center, ch + 1);
    }
}

void show (int u, int p) {
    D3 (u, p, ans[u]);
    for (int v : G[u]) {
        if (v == p) {
            continue;
        }
        show (v, u);
    }
}

void solve() {
    RD (n);
    for (int i = 1; i <= n; ++i) {
        G[i].clear();
        ans[i] = '?';
    }
    for (int i = 1; i <= n - 1; ++i) {
        int u, v;
        RD (u, v);
        G[u].push_back (v);
        G[v].push_back (u);
    }
    dep[1] = 0;
    int leaf1 = dfs (1, 1);
    dep[leaf1] = 0;
    int leaf2 = dfs (leaf1, leaf1);
    int center = find_center (leaf1, leaf1, leaf2).first;
//    D3 (leaf1, leaf2, center);
    write (center, 'A');
//    show (center, center);
    for (int i = 1; i <= 10; ++i) {
        printf ("%c ", ans[i]);
    }
    puts ("");
}


int main() {
    int t = 1;
#ifdef LOCAL
    freopen ("./data.in", "r", stdin);
    RD (t);
#endif // LOCAL

    cout << fixed << setprecision (12);
    cerr << fixed << setprecision (12);
//    ios::sync_with_stdio (false);
//    cin.tie (nullptr);
//    cout.tie (nullptr);
    for (int i = 1; i <= t; ++i) {
//        printf ("Case #%d: ", i);
        solve();
    }
    puts ("");
    return 0;
}

