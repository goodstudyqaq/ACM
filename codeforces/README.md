# Codeforces AC Codes

# 2021.12(DP)
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s5{background-color:#ffffff;text-align:left;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;font-family:'Arial';font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{background-color:#ffffff;text-align:center;color:#000000;font-family:'Arial';font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{background-color:#ffffff;text-align:left;color:#000000;font-family:'Arial';font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{background-color:#fbbc04;text-align:left;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;font-family:'Arial';font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{background-color:#d9d9d9;text-align:left;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;font-family:'Arial';font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{background-color:#ffffff;text-align:right;color:#000000;font-family:'Arial';font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-vertical-handle"></th><th id="627986481C0" style="width:83px;" class="column-headers-background">A</th><th id="627986481C1" style="width:247px;" class="column-headers-background">B</th><th id="627986481C2" style="width:39px;" class="column-headers-background">C</th><th id="627986481C3" style="width:97px;" class="column-headers-background">D</th><th id="627986481C4" style="width:395px;" class="column-headers-background">E</th><th id="627986481C5" style="width:264px;" class="column-headers-background">F</th></tr></thead><tbody><tr style="height: 20px"><th id="627986481R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" dir="ltr">日期</td><td class="s0" dir="ltr">交叉选题</td><td class="s0" dir="ltr">难度</td><td class="s0" dir="ltr">标签</td><td class="s0" dir="ltr">思考记录</td><td class="s0" dir="ltr">备注</td></tr><tr><th style="height:3px;" class="freezebar-cell freezebar-horizontal-handle"></th><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td></tr><tr style="height: 101px"><th id="627986481R1" style="height: 101px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 101px">2</div></th><td class="s1" dir="ltr">12/1</td><td class="s2" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/990/G">CF990G. GCD Counting<br></a></span><span style="color:#000000;">给你一颗树，每个结点有一个值，g(x, y) 表示 x 到 y 经过的结点的 gcd值，现在求 gcd = 1, 2, 3... 2e5 每个的个数</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">暴力 gcd 树 dfs</td><td class="s3" dir="ltr">todo: 写一下正确写法<br>看上去就可以树上启发式合并去搞一下，也就是暴力。<br>** unordered_map 用的内存比 map 大，但是速度比 map 快。</td><td class="s3"></td></tr><tr style="height: 105px"><th id="627986481R2" style="height: 105px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 105px">3</div></th><td class="s1" dir="ltr">12/2</td><td class="s2" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/959/F">CF959F. Mahmoud and Ehab and yet another xor task<br><br></a></span><span style="color:#000000;">给你一个数组，有 q 次询问，每次询问给出 l, x，求前 l 个数的子序列异或和为 x 的个数</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">线性基 结论</td><td class="s3" dir="ltr">这里有一个结论，有 x 个数，这 x 个的线性基的大小为 y，如果异或和能组成 val 的话，那么子序列能组成 val 的个数为 2 ^ (x - y)(这个结论也比较好推)<br>那么这里就暴力求每个点前缀的线性基就行了。</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s1" dir="ltr">12/3</td><td class="s4" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1367/F2">CF1367F2. Flying Sort (Hard Version)<br></a></span><span style="color:#000000;">有 n 个数 (n &lt;= 2e5)，里面有重复数字，现在你有两种操作，选择一个数把它放到头，选择一个数把它放到尾，求操作最小次数使得数组有序</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">dp<br>状态设计</td><td class="s3" dir="ltr">1. 考虑选择一个最长子序列，使得保持这个子序列不变，其他元素经过操作之后变成一个不递减的序列。<br>2. 状态和转移很精髓， dp[i] 表示以 i 结尾的最长值连续序列的长度，<br>如果前面有 a[i], 那么 dp[i] = max(dp[i], dp[last[a[i]]] + 1)<br>如果 a[i] - 1 前面出现完毕 dp[i] = max(dp[i], dp[first[a[i] - 1]] + cnt[a[i] - 1])<br>如果 a[i] - 1 没有出现完毕 dp[i] = max(dp[i], now_cnt[a[i] - 1] + 1)<br></td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s1" dir="ltr">12/4</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1499/E">CF1499E. Chaotic Merge<br></a></span><span style="color:#000000;">现在有两个字符串 x 和 y，现在有一个 merge 字符串 z，这个 z 是根据序列 a 而来，a[i] = 0，则把 x 开头加入 z 的尾，a[i] = 1，则把 y 开头加入 z 的尾，如果 z 的每个相邻字符都不相等，那么它被称为 chaotic。现在 f(l1, r1, l2, r2) 表示 x 的子串 [l1, r1] 和 y 的子串 [l2, r2] 有多少个 chaotic 的 z，求所有 x 的子串和 y 的子串的 f 的和。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">dp<br>状态设计</td><td class="s3" dir="ltr">dp[i][j][0/1] 表示 x 结尾到 i，y 的结尾到 j，最后一个放 x 还是 y 的方案个数。状态转移处理好起始串就好。</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s1" dir="ltr">12/5</td><td class="s2" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1237/E">CF1237E. Balanced Binary Search Trees<br></a></span><span style="color:#000000;">给你一个数 n，表示有一个二叉搜索树，现在有两个要求。<br></span>1. 如果 v 在 u 的左边，他们的奇偶性不同，如果 v 在 u 的右边，他们的奇偶性相同<br>2. 这颗搜索树要求 perfectly， 即所有结点的深度和最小<br>输出满足要求的树的个数</td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">构造，找规律</td><td class="s3" dir="ltr">好难<br>1. 首先根节点和 n 同奇偶，那么右子树的节点个数为偶数个。<br>2. 定了根节点的话，那么左右子树可以看成相同的问题，去考虑，也就是可以递归。<br>3. 然后找规律，层数为 1 的只有 1，层数为 2 的有 2，层数为 3 的有 4 和 5...继续往后的话能满足要求的右子树只有 4，而和 4 同层的只有 5。那么只能构成 8 和 9。。。以此类推即可。</td><td class="s3"></td></tr><tr style="height: 114px"><th id="627986481R6" style="height: 114px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 114px">7</div></th><td class="s1" dir="ltr">12/6</td><td class="s4" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/698/C">CF698C. LRU<br></a></span><span style="color:#000000;">有 n 个元素，cache 只能存 k 个元素，存的机制为 LRU，给出这 n 个元素出现的概率，问 10^100 次方后，cache 中每个点出现的期望。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">数学题<br>公式<br>状压dp</td><td class="s3" dir="ltr">dp[s] 表示当前 cache 里的状态，状态转移需要求一个等比数列求和，从 s 转移到 (s | (1 &lt;&lt; j))转移的概率是 (p[j] + p[j] * P[s] + p[j] * P[s] * P[s] ...)</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s1" dir="ltr">12/7</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/643/C">CF643C. Levels and Regions<br></a></span><span style="color:#000000;">现在你在玩一个游戏，一共有 n 个关卡，需要把 n 个关卡分成 k 个 group，你需要从第一个 group 打到最后一个 group，在同一个 group 下，你需要从最小关卡打到最大关卡，但是关卡出现是随机的，每个关卡有一个概率，随机的方式是已经打过的关卡+第一个没过的关卡，打一个关卡需要 1h，最少需要花多少时间打完所有关卡。(k &lt;= 50)</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">斜率dp</td><td class="s3" dir="ltr">1. 首先可以想到 dp[i][j] 表示考虑从 1 到 i 这 i 个关卡，分成 j 个 group 需要花的最少时间。<br>2. 考虑一个 group 下需要花的时间的期望。<br>3. 根据式子进行斜率 dp 优化复杂度就行。</td><td class="s3"></td></tr><tr style="height: 141px"><th id="627986481R8" style="height: 141px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 141px">9</div></th><td class="s1" dir="ltr">12/8</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1609/E">CF1609E. William The Oblivious<br></a></span><span style="color:#000000;">现在有一个长度为 n 的字符串，里面只有 abc 3 种字符，现在有 q 次询问，每次询问包括 (pos, c)，表示把 s[pos] 字符替换成 c，每次询问需要输出最少需要修改多少个字符，使得不存在 abc 这样的子序列。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">线段树<br>状压<br>状态设计</td><td class="s3" dir="ltr">子序列确实难搞，考虑每个区间维护一个 mi[s]，表示这个区间的子序列只包含 s 这个状态需要修改多少个字符。而 s 里面应该维护 a，b，c，ab，abc，5种状态.</td><td class="s3"></td></tr><tr style="height: 150px"><th id="627986481R9" style="height: 150px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 150px">10</div></th><td class="s1" dir="ltr">12/9</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1059/E">CF1059E. Split the Tree<br></a></span><span style="color:#000000;">给你一颗 n 个节点的树，每个节点有一个权值 w，现在需要把这个树分成若干个路径，每条路径需要满足节点总个数不超过 L，权值和不超过 S，问最少路径个数</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">贪心 倒推<br>树上倍增</td><td class="s3" dir="ltr">**todo: 用树上倍增过这个题<br>从叶子节点去考虑这个问题，贪心的往上走就行</td><td class="s3"></td></tr><tr style="height: 128px"><th id="627986481R10" style="height: 128px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 128px">11</div></th><td class="s1" dir="ltr">12/10</td><td class="s2" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/906/C">CF906C. Party<br></a></span><span style="color:#000000;">现在有一个派对，有 n 个人参加，如果 a 和 b 是朋友的话，那么 a 和 b 有一条边，现在有一个操作，就是选择一个点 u，与 u 为朋友的点可以两两成为朋友。问最少操作多少次，可以让所有人两两为朋友。n &lt;= 22</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">状压dp</td><td class="s3" dir="ltr">好难的状压<br>1. dp[s] 表示状态 s 两两成为朋友需要操作的次数。<br>2. 怎么转移呢？这里和之前的状压不同，枚举 i，转移的状态不是 s | (1 &lt;&lt; i)，而是和 i 相连的所有人，即预处理出和 i 相连的状态 s2[i], 转移后的状态为 s | s2[i].</td><td class="s3"></td></tr><tr style="height: 179px"><th id="627986481R11" style="height: 179px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 179px">12</div></th><td class="s1" dir="ltr">12/11</td><td class="s5" dir="ltr"><a target="_blank" href="https://codeforces.com/problemset/problem/1096/G">CF1096G. Lucky Tickets</a></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">生成函数 NTT</td><td class="s3" dir="ltr">暂时放着，前置知识没学</td><td class="s3"></td></tr><tr style="height: 148px"><th id="627986481R12" style="height: 148px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 148px">13</div></th><td class="s1" dir="ltr">12/12</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/498/B">CF498B. Name That Tune<br></a></span><span style="color:#000000;">有 n 首歌，听一首歌需要花 1s，你有 p[i] 的概率能听出这首歌的名字，另外有个条件，即听了t[i] 后，这次你一定能听出这首歌的名字。问花 T s能听出的歌的个数期望</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">概率dp<br>复杂度优化</td><td class="s3" dir="ltr">耐心推公式就行<br>dp[i][j] 表示第 j s 听出第 i 首歌的概率。普通的转移是 n*T*T，gg，需要根据公式发现 dp[i][j] 和 dp[i][j - 1] 之间的关系，从而把最后一个 T 干掉</td><td class="s3"></td></tr><tr style="height: 134px"><th id="627986481R13" style="height: 134px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 134px">14</div></th><td class="s1" dir="ltr">12/13</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1304/F2">CF1304F2. Animal Observation (hard version)<br></a></span><span style="color:#000000;">有 n * m 的矩阵，在每一行你可以选一个 2 * k 的矩阵区域，即包括这一行，和下一行这个区域的数，现在要求能包括的数的和最大是多少</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">线段树</td><td class="s3" dir="ltr">可以想到 dp[i][j] 表示当前要选择第 i 行，上一行选择的是[j, j + k - 1] 列，的最大的和。递推的时候其实就是要求一个最大值，但包括的点需要进行一个减值操作。所以用一个线段树维护就行。</td><td class="s3"></td></tr><tr style="height: 127px"><th id="627986481R14" style="height: 127px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 127px">15</div></th><td class="s1" dir="ltr">12/14</td><td class="s2" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1109/D">CF1109D. Sasha and Interesting Fact from Graph Theory<br></a></span><span style="color:#000000;">有 n 个节点，要组成一个生成树，每条边的权值为 [1, m]，现在你有两个喜欢的点 a 和 b，要求生成树上 a 到 b 的距离和也为 m。问符合要求的生成树的个数</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">广义Cayley定理<br>组合数学<br>式子推导</td><td class="s3" dir="ltr">1. 可以想到枚举 a 和 b 之间的边数，然后分开求个数。<br>**todo: 整理组合数学</td><td class="s3"></td></tr><tr style="height: 142px"><th id="627986481R15" style="height: 142px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 142px">16</div></th><td class="s1" dir="ltr">12/15</td><td class="s2" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1582/F2">CF1582F2. Korney Korneevich and XOR (hard version)<br><br></a></span><span style="color:#000000;">给你一个长度为 n 的数组，问它所有的递增子序列的异或和有哪些</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">优雅的暴力</td><td class="s3" dir="ltr">一开始的做法和题解不一样，导致优化不了。想不出来的时候可以换个思路<br>v[i] 表示最后一个数不超过 i 的所有不同异或和，那么遍历到 a[i] 时，a[i] 可以和 v[a[i]] 里的所有数异或，并把值赋给 v[a[i] + 1], v[a[i] + 2].... 这样复杂度为 n * 5000 * 常数(用 bitset 优化的话)。<br>这里有一个可以优化的地方，就是把之前已经传递上去的值删掉，之后进行传递的时候就不考虑这个值。那么复杂度变成 n + 5000 * 5000</td><td class="s3"></td></tr><tr style="height: 98px"><th id="627986481R16" style="height: 98px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 98px">17</div></th><td class="s1" dir="ltr">12/16</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/24/D">CF24D. Broken robot<br></a></span><span style="color:#000000;">给定一个 n 行 m 列的格子，有一个机器人在 (i, j) 他会等概率往左右下走或者停住不动。如果在边缘则不会往边缘方向走，问它能到最下一行的期望步数。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">高斯消元优化<br>概率计算</td><td class="s3" dir="ltr">推公式发现是解方程，但方程比较特殊，参考：https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s1" dir="ltr">12/17</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1101/F">CF1101F. Trucks and Cities<br></a></span><span style="color:#000000;">有 n 个城市，m 个卡车，这 m 个卡车能被描述为 s, f, c, r, 即从 s 到 f，每走 1 个城市花费 c 油，最多能补充 r 次油，补充油只能在城市补充。你需要最小化 V，即每个卡车能带的油量，使得每辆卡车都能够顺利运行。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">DP<br>状态设计 二分优化</td><td class="s3" dir="ltr">dp[i][j][k] 表示从 i 到 j，冲 k 次油需要遇到的最大距离最小是多少。</td><td class="s3"></td></tr><tr style="height: 111px"><th id="627986481R18" style="height: 111px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 111px">19</div></th><td class="s1" dir="ltr">12/18</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/780/F">CF780F. Axel and Marston in Bitland<br></a></span><span style="color:#000000;">给一个有向图，每条边的类型为 0 or 1.最开始你在 1 位置，你要走的边的类型顺序为 </span> P, PB, PBBP, PBBPBPPB, PBBPBPPBBPPBPBBP...<br>问最多能走多少步</td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">倍增 dp</td><td class="s3" dir="ltr">倍增dp 很明显。。。<br>dp[i][0/1][u][v] 表示走 1 &lt;&lt; i 步，以 0 或 1 开始是否能从 u 到 v。</td><td class="s3"></td></tr><tr style="height: 90px"><th id="627986481R19" style="height: 90px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 90px">20</div></th><td class="s1" dir="ltr">12/19</td><td class="s2" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/825/F">CF825F. String Compression<br></a></span><span style="color:#000000;">给你一个字符串，现在你可以对其进行压缩，压缩方式为 c1,s1,c2, s2, c3, s3... c1 表示 s1 出现的次数，依次类推，输出压缩后的最短长度。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">kmp 最小循环节</td><td class="s3" dir="ltr">1. dp[i] = min(dp[i], dp[j - 1] + mi(j, i))<br>kmp 预处理出 mi 即可</td><td class="s3"></td></tr><tr style="height: 111px"><th id="627986481R20" style="height: 111px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 111px">21</div></th><td class="s1" dir="ltr">12/20</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1598/F">CF1598F. RBS<br></a></span><span style="color:#000000;">有 n 个括号序列，你可以按照任意顺序来重排它们，使得前缀合法序列最多。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">状压dp 预处理</td><td class="s3" dir="ltr">dp[s] 表示已经考虑了 s 状态的括号序列，目前仍然是合法的最大前缀合法序列个数。</td><td class="s3"></td></tr><tr style="height: 104px"><th id="627986481R21" style="height: 104px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 104px">22</div></th><td class="s1" dir="ltr">12/21</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/526/E">CF526E. Transmitting Levels<br></a></span><span style="color:#000000;">给你 n 个数(首尾相连)，q 次询问，每次询问包括一个值 b，问最少需要把这 n 个数分成多少个连续的组，每组的和不超过 b。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">分块</td><td class="s3" dir="ltr">每次询问预处理出每个点能跳到的位置go[i]，那么取 go[i] - i 最小的 idx，进行枚举即可。复杂度为 On</td><td class="s3"></td></tr><tr style="height: 146px"><th id="627986481R22" style="height: 146px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 146px">23</div></th><td class="s1" dir="ltr">12/22</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/498/D">CF498D. Traffic Jams in the Land<br></a></span><span style="color:#000000;">有 n + 1 个城市在一条线上，即第 i 个能到第 i + 1 个，每个城市有一个值 a[i](1 &lt;= a[i] &lt;= 6), 如果当前时间不是 a[i] 的倍数，那么你可以到达 i + 1 城市，并且当前时间 +1，否则的话，你仍然在第 i 个城市。有两种询问，第一种询问从 x 到 y 要多久时间，第二种询问修改 a[i].</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">线段树</td><td class="s3" dir="ltr">可以发现 a 只有 6 种可能，那么最小公倍数为 120，sum[val][rt] 表示开始时间是 val 的倍数，走完这段线段要花的时间，搞个线段树完事。</td><td class="s3"></td></tr><tr style="height: 121px"><th id="627986481R23" style="height: 121px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 121px">24</div></th><td class="s1" dir="ltr">12/23</td><td class="s4" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1542/E1">CF1542E1. Abnormal Permutation Pairs (easy version)<br><br></a></span><span style="color:#000000;">长度为 n(n &lt;= 50) 的排列组合，问有多少对排列(p, q) p 的字典序小于 q，逆序对数大于 q。个数模 mod</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">计数<br>组合数学</td><td class="s3" dir="ltr">1. sum[i][j] 表示长度为 i，逆序对个数小于 j 的方案数，这个纸上推一推就出来了。<br>2. 那么首先枚举相等的长度 i，在枚举第 i + 1 位的差，再枚举 q 的逆序对个数即可。</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s1" dir="ltr">12/24</td><td class="s4" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1038/E">CF1038E. Maximum Matching<br></a></span><span style="color:#000000;">有 n 个块，每个块组成方式为 [color1|value|color2](1 &lt;= color &lt;= 4) 这些块都可以翻转，现在想让这些块连接起来，即相同颜色就可以连起来，要求和最大，问最大是多少</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">欧拉路径 分类讨论</td><td class="s3" dir="ltr">没想到分类讨论。。。<br>分类讨论度数的情况，如果奇数度数为 0，那么其实是找连通块的最大值。如果是 2，那么首先枚举奇数点，再枚举偶数点。如果是 4个的话，那么先删掉一条边，然后枚举奇数点，再枚举偶数点</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s1" dir="ltr">12/25</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/744/C">CF744C. Hongcow Buys a Deck of Cards<br></a></span>n(n &lt;= 16)个物品，每个物品要么是红色要么是黑色，每一回合你有两种选项，第一个选项是获得 1 个红色卡片以及 1 个黑色卡片，第二个选项是购买一个物品。购买一个物品需要 max(r - Ai, 0) 个红色卡片以及 max(b - Bi) 个黑色卡片，r 为购买这个物品时拥有的红色物品个数，b 为购买这个物品时拥有的黑色物品个数。问最少需要多少个回合能把所有物品购买完。</td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">状态设计<br>状压dp<br>正难则反</td><td class="s3" dir="ltr">dp[s][r] 表示挑选状态为 s 的卡片，省下的红色卡片个数为 r，最多能省多少个蓝色卡片</td><td class="s3"></td></tr><tr style="height: 166px"><th id="627986481R26" style="height: 166px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 166px">27</div></th><td class="s1" dir="ltr">12/26</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/641/D">CF641D. Little Artem and Random Variable<br></a></span><span style="color:#000000;">有两个面数为 n 的骰子，每一面出现的概率不一样，现在告诉出现 max(a, b) 和 min(a, b) 的概率，算出每一面出现的概率</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">解方程</td><td class="s3" dir="ltr">suma(i) 表示第一个骰子出现 1 到 i 的概率，sumb(i) 表示第二个骰子出现 1 到 i 的概率。<br>那么 \sum_i^j max(i) = suma(j) * sumb(j), \sum_i^n min(i) = v2 = (1 - suma(i - 1)) * (1 - sumb(i - 1))</td><td class="s3"></td></tr><tr style="height: 98px"><th id="627986481R27" style="height: 98px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 98px">28</div></th><td class="s1" dir="ltr">12/27</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/31/E">CF31E. TV Game<br></a></span><span style="color:#000000;">有 n * 2 个数，你要把它分成两部分，使得两部分的数的和最大 n &lt;= 18</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">水 <br>meet in the middle</td><td class="s3" dir="ltr">meet in the middle 搞一下就行</td><td class="s3"></td></tr><tr style="height: 137px"><th id="627986481R28" style="height: 137px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 137px">29</div></th><td class="s1" dir="ltr">12/28</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/115/E">CF115E. Linear Kingdom Races<br></a></span><span style="color:#000000;">你有 n 条道路，每条道路都需要维修，维修费用为 a[i], 现在有 m 个车要用道路，每个车可以描述为 l, r, p, 即它要用 [l, r] 的车，并且可以支付你 p 费用。问你最多可以获得多少钱</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">线段树优化dp</td><td class="s3" dir="ltr">1. 首先可以想到 dp[i] 表示考虑 1 到 i 的道路可以获得的最多钱数。 dp[i] = max(dp[i], dp[j] + pay[j + 1, i] - cost(j + 1, i))<br>2. cost 好考虑，一个前缀和就完事了，那么 pay 怎么考虑呢，如果从左到右枚举 i，即右端点，那么从 1 到一辆车的左下标 l，都需要加上这个车的 p。线段树就完事了</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s1" dir="ltr">12/29</td><td class="s4" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/756/D">CF756D. Bacterial Melee<br></a></span><span style="color:#000000;">有一串n个字母，每个位置的字母可以同化边上的一个字母，
<br>　　比如：ab可以变成aa或者bb。
<br>　　相对的两个同化不能同时发生，比如ab不能变成ba。
<br>　　现在给你一个字符串，问你经过任意次数的同化过程，最多能生成多少个字符串。</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">组合数学<br>性质分析</td><td class="s3" dir="ltr">1. 首先考虑原始串，把它变成相邻都不相同的串s2，之后生成的串一定是根据它生成的。<br>2. 考虑 s2 相邻不相同的子序列，s3， 长度为 len，那么方案数为 C(n - 1, len - 1)<br>3. dp[i][j] 表示长度为 i 的相邻不相同的子序列，最后一个字符为 j 的个数。</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s1" dir="ltr">12/30</td><td class="s4" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/1107/G">CF1107G. Vasya and Maximum Profit<br></a></span><span style="color:#000000;">有 n 个问题，每个问题有两个值，一个值是它的难度(题目是按照难度递增给出的，每个题目的难度不同)，一个值是它的价格，你需要选择一个区间，你获得的奖励为题目个数*a - 题目价格 - max(gap(l, r - 1)) gap(l, r - 1) = max(d[i + 1] - d[i]) ^ 2<br></span>问最大奖金是多少</td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">分治<br>rmq</td><td class="s3" dir="ltr">1. 每个题目的难度不同这个条件很关键。<br>2. 先说做法，首先 rmq 维护出区间 diff 最大值，sum 最大值和最小值，那么分治求区间结果，mid = diff_idx(l, r)，而这个区间的结果为 sum_max - sum_min - diff[mid]<br>3. 复杂度很玄学最坏 nlogn</td><td class="s3"></td></tr><tr style="height: 112px"><th id="627986481R31" style="height: 112px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 112px">32</div></th><td class="s1" dir="ltr">12/31</td><td class="s5" dir="ltr"><span style="text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;color:#1155cc;"><a target="_blank" href="https://codeforces.com/problemset/problem/886/E">CF886E. Maximum Element<br></a></span><span style="color:#000000;">有一个长度为 n 的排列，如果一个数后面有 k 个比它小的数，那么它可以是作为这个排列的最大值。问最大值不是 n 的方案数个数</span></td><td class="s1" dir="ltr">2400</td><td class="s3" dir="ltr">组合数学<br>性质分析</td><td class="s3" dir="ltr">1. 枚举 n 所在的位置，那么可以考虑为长度为 len，最后一个数在最后一个位置，有最大值的方案数。<br>2. 考虑 n - 1 这个数所在的位置，如果它在[1, n - k - 1] 那么合理，其他数随便排，否则我们需要考虑它之前的数是否能够出现最大值。所以递推式可以写成<br>f[n]=(n-k-1)(n-2)！+Σf[j] A(n-2,n-j-1)。后面随便优化一下即可。</td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s3"></td><td class="s3"></td><td class="s3"></td><td class="s3"></td><td class="s3"></td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s3" dir="ltr">比赛记录</td><td class="s3"></td><td class="s3"></td><td class="s3"></td><td class="s3"></td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s1" dir="ltr">12/14</td><td class="s5" dir="ltr"><a target="_blank" href="https://codeforces.com/contest/1618">https://codeforces.com/contest/1618</a></td><td class="s3"></td><td class="s3"></td><td class="s3"></td><td class="s3"></td></tr><tr style="height: 20px"><th id="627986481R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s3"></td><td class="s5" dir="ltr"><a target="_blank" href="https://codeforces.com/contest/1618/problem/G">https://codeforces.com/contest/1618/problem/G</a></td><td class="s3"></td><td class="s3"></td><td class="s3"></td><td class="s3"></td></tr></tbody></table></div>